
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<!--last modified on Saturday, October 03, 1998 04:19 PM -->
<HTML><!-- #BeginTemplate "/Templates/pink.dwt" --><!-- DW6 -->
<HEAD>
<!-- #BeginEditable "doctitle" -->
<TITLE>Related Work</TITLE>
<!-- #EndEditable --> 
<meta http-equiv=content-type content="text/html; charset=UTF-8">
<meta name="Author" content="Mark S. Miller">
<link rel=author rev=made title="Mark S. Miller">
<META NAME="description" CONTENT="E: Cryptographic Capabilities for Distributed Smart Contracting">
<META NAME="keywords" CONTENT="p2p, p2p language, p2p computing, p2p objects, secure p2p, p2p capabilities, object oriented p2p,
  capability-based p2p, Capability Security, Capabilities, Cryptography, Distributed Objects, Distributed
  Language, Distributed Capabilities, Lambda Calculus, Scripting Language, Distributed Language, Persistent
  Language, Persistent Capabilities, Persistent Objects, Java Shell, Capability Shell, Scripting Java, Smart
  Contracting, Agoric E-Commerce, Open Source, Message pipelining, quasi literal, vat, event loop, granovetter diagram ">
<link rel="stylesheet" href="../../../erights.css" type="text/css">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFEEDD" LINK="#0000FF" VLINK="#800080">
<TABLE BORDER="0" width="100%">
  <TR VALIGN="TOP"> 
    <TD WIDTH="10%">&nbsp; </TD>
    <TD> <TABLE BORDER="0" WIDTH="100%">
        <TR> 
          <TD ALIGN="LEFT" valign="top"> <table cellpadding="2">
              <tr> 
                <td valign="top" align="left" colspan="3"><a href="../../../index.html"><img src="../../../images/e-lambda.gif" width="32" height="32" border="0" alt="ERights Home"></a> 
                  <!-- #BeginEditable "Path" -->/&nbsp;<a href="../../index.html">data</a>&nbsp;/&nbsp;<a href="../index.html">serial</a>&nbsp;/&nbsp;<a href="index.html">jhu-paper</a>&nbsp;<!-- #EndEditable --></td>
              </tr>
              <tr> 
                <td valign="top" align="right"><!-- #BeginEditable "PrevButton" --><a href="upgrade.html" title="Back to: Persistence and Upgrade"><img src="../../../images/prev.gif" width="64" height="32" alt="Back to: Persistence and Upgrade" border="0"></a><!-- #EndEditable --></td>
                <td valign="bottom" align="left"><!-- #BeginEditable "FirstButton" --><!-- #EndEditable --></td>
                <td valign="top" align="left"><!-- #BeginEditable "NextButton" --><a href="conclusions.html" title="On to: Conclusions"><img src="../../../images/next.gif" width="64" height="32" alt="On to: Conclusions" border="0"></a><!-- #EndEditable --></td>
              </tr>
            </table></TD>
          <TD rowspan="2" ALIGN="RIGHT"> <P ALIGN="RIGHT"><FONT SIZE="7"><!-- #BeginEditable "BigTitle" --><FONT SIZE="7"><B>Related
              Work</B></FONT><!-- #EndEditable --></FONT> </TD>
        </TR>
        
      </TABLE>
      <hr> <!-- #BeginEditable "LongBody" -->
      <P ALIGN="left"><font color="#FF0000">*** incoherent notes here to the end
        of this file. Do Not Read ****</font>
      <h1 ALIGN="left">Mozart / OZ</h1>
      <P ALIGN="left">[<a href="acks-n-refs.html#Duchier98">Duchier98</a>]
      <blockquote>
        <p>All data structures reside in an abstract store, whose states take
          the form of a directed graph. The nodes of the graph represent entities
          like integers, records, variants (obtained by constructors), assignable
          references cells, procedures (i.e., closures), and operations (i.e.,
          built-in procedures). Procedures are nodes whose departing links point
          to lexically bound nodes. For instance, the SML expression let val x
          = fn y =&gt; z(y) in ... end will bind x to a procedure node with one
          departing link that points to the node bound to z. Given an execution
          state, the data structure associated with a node x in the abstract store
          is the maximal subgraph of the abstract store that is reachable from
          x. We distinguish between two types of operations (i.e., built-in procedures).
          Global operations have the same semantics in every VM (e.g., addition
          of numbers or creation of threads). Local operations affect the resources
          of a particular VM and are hence tied to a particular VM. All operations
          that are available through the base environment at compile time are
          global. Access to local operations can only be obtained through system
          modules, which are tied to the VM in which they exist. A data structure
          in a VM can be pickled if and only if it does not contain futures or
          local operations. By excluding futures, we make sure that they are not
          cut off from the threads that are supposed to eliminate them. By excluding
          local operations, we ensure that loading a pickle will not create a
          data structure that captures local operations of the loading VM. This
          is an essential security property of our model [...]. If the pickle
          operation encounters a future, it requests it and blocks. Once the future
          is eliminated it resumes. This way pickling is compatible with lazy
          linking. If the pickle operation encounters a local operation, it raises
          an error exception. Next we make precise what we mean by a clone of
          a data structure. Let x be the original data structure and y be a clone
          of x. Then the graphs reachable from x and y must be graph isomorphic
          with respect to their roots x and y. Moreover, the reference cells reachable
          from x must all be different from the reference cells reachable from
          y. Finally, if we redirect all external links into the graph rooted
          by x to the respective nodes of the graph rooted by y, no difference
          must be observable when the VM proceeds. </p>
      </blockquote>
      <p>Cardelli, Vijay</p>
      <p>Sun, NeXT, Kaleida Labs, Waterken</p>
      <p>Rees' uneval</p>
      <h1>XMLEncoder</h1>
      <p><a href="http://java.sun.com/j2se/1.4.1/docs/api/java/beans/XMLEncoder.html">javadoc</a>
        <a href="http://www.sys-con.com/java/articleprint.cfm?id=2046">jdj article</a>
        <a href="http://java.sun.com/products/jfc/tsc/articles/persistence4/index.html">sun
        article</a></p>
      <h3><a href="http://java.sun.com/j2se/1.4.1/docs/api/java/beans/Statement.html">java.beans.Expression</a></h3>
      <h1>JOSS</h1>
      <p>&nbsp;</p>
      <p>In JOSS, implementing <i>Serializable</i> declares that one's state should
        be divulged to all serializers, independent of whether one is transparent
        in general. We can say that such an object is <i>transparent to all serializers</i>.
        To be transparent to all serializers without being transparent in general
        makes sense only if all serializers are only wielded by objects that are
        universally more trusted than are normal clients. While this may make
        sense for supporting applets, since we are trying to support mutual suspicion,
        our idealized model instead only distinguishes <i>transparent</i> and
        <i>opaque</i>. </p>
      <p>&nbsp;</p>
      <ul>
        <li>
          <p>A non-scalar object is a combination of state and behavior. In a
            conventional object language like Smalltalk or Java, the behavior
            corresponds to a class, and the state of an object consists of a map
            from the name of each instance variable to the corresponding value
            of that variable. (The obvious optimization -- based on knowing that
            all instances of the same behavior will have the same instance variable
            layout -- is left as an exercise for the reader.) </p>
          <p>In <i><b><font color="#009000">E</font></b></i>, the behavior corresponds
            more closely to a lambda expression, but for present purposes these
            can be mapped to Java classes with no loss, so we proceed assuming
            this mapping. The state of an <i><b><font color="#009000">E</font></b></i>
            object is based on its <i>free variables</i> -- variable names used
            within the behavior but defined in the scope enclosing the behavior.
            This is the lambda-equivalent of instance variables. This state is
            a mapping from the name or mangled name of each of free variable to
            the corresponding <i>state</i> of that variable. When the variable
            is defined to be final (using &quot;<tt>def</tt>&quot;), then the
            association is from the name to the value. When the variable is potentially
            mutable (defined using &quot;<tt>var</tt>&quot;), then, since it may
            be shared, the association is from a mangle of the variable name to
            the Slot object containing the current value of the variable.</p>
          <p>&nbsp;</p>
          <p>To accommadate schema evolution, about which more below, if the state
            maps from names unused by the behavior, those associations are ignored.
            If the state is missing some needed associations, by default a behavior
            will complain by throwing an exception (which will terminate unserialization).
            But a clever behavior may have means to cope with this situation.</p>
        </li>
        <li>
          <p><tt>uneval(behavior) =&gt; &lt;import:<i>fully-qualified-name</i>&gt;</tt>
          </p>
          <p>Following JOSS, in order to accommodate schema evolution, covered
            below, we don't actually serialize the behavior itself. Rather, we
            serialize a expression containing an identifier that corresponds to
            the behavior. We ignore here JOSS's serialVersionUID, and assume the
            fully qualified name is used instead. Therefore, the expression we
            serialize is simply one that imports this behavior from the <tt>import__uriGetter</tt>.
            Crucially, only <a href="../../../elib/legacy/taming.html">safe</a>
            classes may be imported by the <tt>import__uriGetter</tt>, so the
            result of evaling / unserializing such an expression will be born
            with any authority. (This restriction is essential, but is not yet
            implemented.) If the evaling / unserializing environment cannot find
            a behavior of the specified name, unserialization fails.</p>
          <p>(In Java, the identity of a class corresponds to a pair of a fully
            qualified name and a ClassLoader. However, JOSS serializes the class's
            identifier but not its ClassLoader. This may be fine when the identifier
            is a serialVersionUID, but when it is a fully qualified name, our idealization
            of JOSS is failing to represent different behaviors by different expressions.
            We could repair this by explicitly representing the Loader as well.
            In fact, the <tt>import__uriGetter</tt> is a Loader, very much like
            a ClassLoader. Once we've presented the Gordian Scalpel, we will have
            enough machinery to consider serializing Loaders as well.) </p>
          <p><i><b><font color="#009000">E</font></b></i>'s syntax discourages
            but does not prohibit the creation of anonymous behavior definitions
            -- the moral equivalent of Java's anonymous inner classes, Scheme's
            anonymous closures, or Smalltalk's BlockClosures. No system we are
            aware of supports the schema evolution of any such anonymous objects.
            (Unfortunately, JOSS acts incoherently in this case, rather than rejecting
            it.) We believe that such support is absent because it is a bad idea:
            since any name automatically assigned doesn't have any programmer-aware
            stability across program versions. In order to support schema evolution,
            anonymous behaviors should not be considered to have a fully qualified
            name valid for use in serialization. Any behavior defined within an
            anonymous behavior also has no valid fully qualified name, since an
            invalid name is on its name-path. Attempting to serialize a behavior
            without a valid fully qualified name must cause serialization to fail.</p>
        </li>
      </ul>
      <p>Putting together some of these elements into a silly example, if <tt>p</tt>
        is a point created by the following code in module <tt>foo.bar</tt>:</p>
      <blockquote>
        <pre>var count :int := 0
def makePoint(x :int, y :int) :any {
    count += 1
    def point implements Transparent {
        <font class="comment"># ... required self revelation ...</font>
        to getX()     :int { x }
        to getY()     :int { y }

        /** How many points have been created? */
        to getCount() :int { count }
    }
}
def p := makePoint(3, 4)</pre>
      </blockquote>
      <p>then <tt>uneval(p)</tt> would yield the string:</p>
      <blockquote>
        <pre>&lt;import:foo.bar$makePoint__C$point__C&gt;.instatiate([
    &quot;x&quot;           =&gt; 3,
    &quot;y&quot;           =&gt; 4,
    &quot;count__Slot&quot; =&gt; settable.makeSlot(1)
])</pre>
      </blockquote>
      <p>Given the decision to save data but not code, it seems a bit ironic that
        the <tt>eval</tt> technique saves the data by turning it into code.</p>
      <p>(This is based on the mapping: <i><b><font color="#009000">E</font></b></i>
        module =&gt; top level Java class. <i><b><font color="#009000">E</font></b></i>
        behavior (ie, object definition expression) =&gt; Java nested class. Since
        nothing in <i><b><font color="#009000">E</font></b></i> maps onto static
        methods of these nested classes, we are free to specify that each of these
        nested classes has the static <tt>instantiate</tt> method assumed above.)</p>
      <p>&nbsp;</p>
      <h2><a name="replacement"></a>Replacement</h2>
      <p>JOSS serialization has many customization hooks, but that provided by
        the <tt>replaceObject</tt> method seems to be universal. All the other
        serialization-customizations that concern us can be expressed, perhaps
        at a loss in efficiency, by overriding only this one method.</p>
      <p>In the <a href="intro.html#ser-example">example shown earlier</a>, we
        specified the null customization by providing the identity function as
        the replace function. What if we provide a different function?</p>
      <blockquote>
        <pre><span class="stdout">? </span><span class="keyword">pragma</span>.syntax(&quot;<span class="litchars">0.8</span>&quot;)

<span class="stdout">? </span><span class="keyword">def</span> <span class="defvar">makeSerializer</span> := &lt;elib:<span class="litchars">serial.makeSerializer</span>&gt;
<span class="stdout"># value: &lt;makeSerializer&gt;</span></pre>
      </blockquote>
      <p>We define the replace function to be one that replaces an integer with 
        the next higher integer, but acts otherwise as an identity function. </p>
      <blockquote>
        <pre><span class="stdout">? </span><span class="keyword">def</span> <span class="defobj">sillyReplacer</span>(<span class="defvar">obj</span>) :any {
<span class="stdout">&gt; </span>    <span class="keyword">if</span> (obj =~ <span class="defvar">i</span> :int) {
<span class="stdout">&gt; </span>        i + 1
<span class="stdout">&gt; </span>    } <span class="keyword">else</span> {
<span class="stdout">&gt; </span>        obj
<span class="stdout">&gt; </span>    }
<span class="stdout">&gt; </span>}
<span class="stdout"># value: &lt;sillyReplacer&gt;

? </span><span class="keyword">def</span> <span class="defvar">sillySerializer</span> := makeSerializer(sillyReplacer)
<span class="stdout"># value: &lt;a Serializer&gt;

? </span><span class="keyword">def</span> <span class="defvar">desc</span> := sillySerializer.record([1, 2, '<span class="litchars">c</span>', "<span class="litchars">foo</span>"]); desc.size()
<span class="stdout"># value: 360</span></pre>
      </blockquote>
      <p>As we see, the reconstruction is just like the original except that each
        integer, no matter where it may appear, has been replaced by its successor.</p>
      <p>This is specified as a mostly trivial variation of our earlier model
        of serialization. </p>
      <p>As a first approximation, whereas previously the serialization cases
        may have looked like:</p>
      <blockquote>
        <pre>def uneval(ref) :any {
    switch (ref) {
        <font class="comment"># ... the above cases using </font>ref<font class="comment"> ...</font>
    }
}</pre>
      </blockquote>
      <p>we would instead have</p>
      <blockquote>
        <pre>def uneval(originalRef) :any {
    def ref := replace(originalRef)
    switch (ref) {
        <font class="comment"># ... the above cases using </font>ref<font class="comment"> ...</font>
    }
}</pre>
      </blockquote>
      <p>We now need to adjust this to form broader equivalence classes for our
        notion of &quot;having already serialized&quot; a reference. In a call
        to uneval(A1), uneval will call its replace function which, let's say,
        returns ARep, which then gets serialized as expression AData. The serializer
        then remembers both A1 and ARep as having been seen, and as having produced
        expression AData. If either are seen again, then a variable is generated
        as before, but this variable is associated with both references. If A1
        is novel but ARep has already been seen, then A1 is added to the equivalence
        pool for the ARep, and a variable reference is generated.</p>
      <p><font color="#FF0000">(*** In the case of a previously seen variable,
        is replace called? Should it be? Replace is called when the original is
        already transparent. Should it be?)</font></p>
      <p>A serializer can thereby be cutomized to serialize graphs containing
        opaque objects, so long as the replacement for these objects is transparent.
        We will make much use of this ability. Traversal proceeds using the fields
        of the transparent replacement. </p>
      <p></p>
      <p>By the above steps, the serializer traverses a virtual graph of transparent
        replacements. This graph is never represented as an actual graph of objects,
        and often it cannot be. If replacement ARep's instance variable myB points
        at original B1, and if the replacement for B1 is BRep, then in the virtual
        replacement graph ARep's myB points at BRep, even though myB may be of
        a type incompatible with BRep. it is fine for a painter to depict a scene
        that's not literally possible, so long as its meant for viewers who know
        how to interpret this depiction -- so long as corresponding unserializers
        are customized to reconstruct a possible graph.</p>
      <h1>&nbsp;</h1>
      <h2>Cycles <i>vs.</i> Resolution</h2>
      <p>Unfortunately, this simple story faces a terribly hard problem. When
        the depicted XRep's myY points at the depicted YRep, then we must initialize
        the evolvedX's myY to point at the appointed resolution of Y, YRes. So
        long as there are no cycles, JOSS does exactly this, as it should, by
        instantiating and resolving objects in child-to-parent order. But when
        there are cycles, JOSS fails in unacceptable ways:</p>
      <blockquote>
        <p>Note - The <tt>readResolve</tt> method is not invoked on the object
          until the object is fully constructed, so any references to this object
          in its object graph will not be updated to the new object nominated
          by <tt>readResolve</tt>. [...] Therefore in cases where an object being
          serialized nominates a replacement object whose object graph has a reference
          to the original object, deserialization will result in an incorrect
          graph of objects. [<a href="http://robocode.alphaworks.ibm.com/docs/jdk1.3/guide/serialization/spec/input.doc6.html#5903">ref
          JOSS3.6</a>]</p>
      </blockquote>
      <p>When building a system for the coexistence of mutually suspicious objects,
        any spec that says &quot;under these conditions an incorrect result will
        be returned&quot; must be read as an opportunity for an adversary. Were
        they to purposely induce an incorrect result, how might they disrupt the
        assumptions of others in ways they might exploit? These issues are usually
        hard enough to think about that it is better to fix the spec to remove
        the opportunity.</p>
      <p>Unfortunately, the above problem seems unavoidable in Java, since a Java
        reference cannot exist prior to the existence of the object it designates.
        If evolvedX is to be initialized with YRes, and evolvedY is to be initialized
        with XRes, and if a fully initialized evolvedX is going to participate
        in the calculation of XRes, and if a fully initialized evolvedY is going
        to participate in the calculation of YRes, there would seem to be no order
        that would satisfy all these constraints.</p>
      <p>Our idealization mostly solves the problem by using <i><b><font color="#009000">E</font></b></i>'s
        <a href="../../../elib/concurrency/refmech.html">promises</a> to cheat
        on the notion of &quot;fully initialized&quot;. <i><b><font color="#009000">E</font></b></i>'s
        promises -- like logic variables in logic programming languages, or futures
        [ref Actors], or Channels [ref Joule] -- are references which exist, can
        be passed around, and can be held before it is determined which object
        they designate. Until their target object is determined, we say that the
        promise is <i>unresolved</i>. Once the target is determined, the promise
        is <i>fulfilled</i> and is then equivalent to any normal reference to
        that target.</p>
      <p>When the unserializer, walking from child-to-parent, encounters a depicted
        reference to an ancestor of the current object, it creates a promise to
        represent that reference, and uses that promise to initialize that field
        of the evolved object. Later, when the appointed resolution of the ancestor
        is produced, the promise is resolved to this appointed resolution. Unfortunately,
        if the field being initialized is declared to require a non-promise type,
        which can happen in either Java or <i><b><font color="#009000">E</font></b></i>,
        then unserialization will still fail inappropriately with a thrown exception.
        But this algorithm will never silently return an incorrect graph, which
        is the important property for security. The remaining problem simply gives
        an adversary an opportunity to mount a denial of service attack, which
        <i><b><font color="#009000">E</font></b></i> generally does not claim
        to defend against.</p>
      <!-- #EndEditable --></TD>
    <TD WIDTH="10%" rowspan="2" align="right" valign="bottom"> </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD WIDTH="10%">&nbsp;</TD>
    <TD> <hr>
      Unless stated otherwise, all text on this page which is either unattributed 
      or by Mark S. Miller is hereby placed in the public domain. 
        <div align="center"> 
        <table width="100%" cellpadding="4" cellspacing="0">
          <tr> 
            <td> <table align="left" cellpadding="2">
                <tr> 
                  <td valign="top" align="left" colspan="3"><a href="../../../index.html"><img src="../../../images/e-lambda.gif" width="32" height="32" border="0" alt="ERights Home"></a> 
                    <!-- #BeginEditable "Path2" -->/&nbsp;<a href="../../index.html">data</a>&nbsp;/&nbsp;<a href="../index.html">serial</a>&nbsp;/&nbsp;<a href="index.html">jhu-paper</a>&nbsp;<!-- #EndEditable --></td>
                </tr>
                <tr> 
                  <td valign="top" align="right"><!-- #BeginEditable "PrevButton2" --><a href="upgrade.html" title="Back to: Persistence and Upgrade"><img src="../../../images/prev.gif" width="64" height="32" alt="Back to: Persistence and Upgrade" border="0"></a><!-- #EndEditable --></td>
                  <td valign="bottom" align="left"><!-- #BeginEditable "FirstButton2" --><!-- #EndEditable --></td>
                  <td valign="top" align="left"><!-- #BeginEditable "NextButton2" --><a href="conclusions.html" title="On to: Conclusions"><img src="../../../images/next.gif" width="64" height="32" alt="On to: Conclusions" border="0"></a><!-- #EndEditable --></td>
                </tr>
              </table></td>
            <td> <table border="3" align="center" cellpadding="6" cellspacing="3">
                <tr> 
                  <td> <div align="center"><font size="-1"><a href="../../../elib/index.html">ELib</a> 
                      &nbsp;&nbsp; <a href="../../../elang/index.html">E Language</a> 
                      &nbsp;&nbsp; <a href="../../../smart-contracts/index.html">Smart 
                      Contracts</a> &nbsp;&nbsp; <a href="../../../related.html">Related</a> 
                      </font></div></td>
                </tr>
                <tr> 
                  <td> <div align="center"><font size="-1"><a href="../../../download/index.html">Download</a> 
                      &nbsp;&nbsp; <a href="http://mumble.net/e/faq.html">FAQ</a> 
                      &nbsp;&nbsp; <a href="../../../javadoc/index.html">API</a> &nbsp;&nbsp; 
                      <a href="http://www.eros-os.org/pipermail/e-lang/">Mail 
                      Archive</a> &nbsp;&nbsp; <a href="../../../donate.html">Donate</a></font></div></td>
                </tr>
              </table></td>
            <td><div align="right"> 
                <p><a href="https://sourceforge.net/tracker/?func=add&amp;group_id=75274&amp;atid=551529"><i>report 
                  bug</i></a> (including <a href="http://validator.w3.org/check/referer">invalid 
                  html</a>) </p>
                <p><a href="http://www.epic.org/crypto/"><img src="../../../images/key.gif" width="37" height="19" alt="Golden Key Campaign" border="0"></a>&nbsp;<a href="http://www.eff.org/br/"><img src="../../../images/ribbon.gif" width="18" height="30"
alt="Blue Ribbon Campaign" border="0"></a></div></td>
          </tr>
          
        </table>
      </div></TD>
  </TR>
</TABLE>
</BODY>
<!-- #EndTemplate --></HTML>
