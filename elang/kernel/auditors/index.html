
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<!--last modified on Saturday, October 03, 1998 04:19 PM -->
<HTML><!-- #BeginTemplate "/Templates/pink.dwt" --><!-- DW6 -->
<HEAD>
<!-- #BeginEditable "doctitle" -->
<TITLE>Auditors</TITLE>
<!-- #EndEditable --> 
<meta http-equiv=content-type content="text/html; charset=UTF-8">
<meta name="Author" content="Mark S. Miller">
<link rel=author rev=made title="Mark S. Miller">
<META NAME="description" CONTENT="E: Cryptographic Capabilities for Distributed Smart Contracting">
<META NAME="keywords" CONTENT="p2p, p2p language, p2p computing, p2p objects, secure p2p, p2p capabilities, object oriented p2p,
  capability-based p2p, Capability Security, Capabilities, Cryptography, Distributed Objects, Distributed
  Language, Distributed Capabilities, Lambda Calculus, Scripting Language, Distributed Language, Persistent
  Language, Persistent Capabilities, Persistent Objects, Java Shell, Capability Shell, Scripting Java, Smart
  Contracting, Agoric E-Commerce, Open Source, Message pipelining, quasi literal, vat, event loop, granovetter diagram ">
<link rel="stylesheet" href="../../../erights.css" type="text/css">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFEEDD" LINK="#0000FF" VLINK="#800080">
<TABLE BORDER="0" width="100%">
  <TR VALIGN="TOP"> 
    <TD WIDTH="10%">&nbsp; </TD>
    <TD> <TABLE BORDER="0" WIDTH="100%">
        <TR> 
          <TD ALIGN="LEFT" valign="top"> <table cellpadding="2">
              <tr> 
                <td valign="top" align="left" colspan="3"><a href="../../../index.html"><img src="../../../images/e-lambda.gif" width="32" height="32" border="0" alt="ERights Home"></a> 
                  <!-- #BeginEditable "Path" -->/&nbsp;<a href="../../index.html">elang</a>&nbsp;/&nbsp;<a href="../index.html">kernel</a>&nbsp;<!-- #EndEditable --></td>
              </tr>
              <tr> 
                <td valign="top" align="right"><!-- #BeginEditable "PrevButton" --><a href="../Auditors.html" title="Back to: Auditors"><img src="../../../images/prev.gif" width="64" height="32" alt="Back to: Auditors" border="0"></a><!-- #EndEditable --></td>
                <td valign="bottom" align="left"><!-- #BeginEditable "FirstButton" --><!-- #EndEditable --></td>
                <td valign="top" align="left"><!-- #BeginEditable "NextButton" --><a href="../EMethod.html" title="On to: Method Node"><img src="../../../images/next.gif" width="64" height="32" alt="On to: Method Node" border="0"></a><!-- #EndEditable --></td>
              </tr>
            </table></TD>
          <TD rowspan="2" ALIGN="RIGHT"> <P ALIGN="RIGHT"><FONT SIZE="7"><!-- #BeginEditable "BigTitle" --><FONT SIZE="7"><b>Auditors:<br>
              <font size="5"> An Extensible, Dynamic<br>
              Code Verification Mechanism</font></b></FONT><!-- #EndEditable --></FONT> </TD>
        </TR>
        
      </TABLE>
      <hr> <!-- #BeginEditable "LongBody" -->
      <p ><i>Adapted from <a href="http://www.sims.berkeley.edu/%7Eping/auditors/">http://www.sims.berkeley.edu/~ping/auditors/</a>.</i></p>
      <p align=CENTER style=" line-height: 0.46cm"><font  style="font-size: 11pt"><b>Ka-Ping
        Yee</b></font><br>
        <font  style="font-size: 11pt">Computer Science Department</font><br>
        <font  style="font-size: 11pt">University of California, Berkeley</font><br>
        <font  style="font-size: 11pt">ping-at-zesty.ca</font></p>
      <p align=CENTER style=" line-height: 0.46cm"><font  style="font-size: 11pt"><b>Mark
        S. Miller</b></font><br>
        Hewlett Packard Laboratories<br>
        John Hopkins University<br>
        <font  style="font-size: 11pt">markm-at-caplet.com</font></p>
      <div id="Section2">
        <h1>Abstract</h1>
        <p>We introduce <i>auditors</i>, a program annotation and verification
          scheme similar to type declarations, but more general in some ways:
          auditors can be dynamically generated and applied at run-time, and can
          inspect the source code of the annotated object. Auditors allow objects
          to make mandatory commitments about their behaviour (such as immutability
          or determinism), as contrasted with types, which constrain data but
          are only discretionary with respect to behaviour. The inspection facility
          is extensible since auditors can themselves be part of the program.
          In particular, we describe an implementation of auditors for <i><b><font color="#009000">E</font></b></i>,
          a language platform for capability-secure distributed programming, and
          apply auditors to make <i><b><font color="#009000">E</font></b></i>
          the first language capable of supporting secure <i>confinement</i> at
          the object level.</p>
        <p><b><font  style="font-size: 11pt" >KEYWORDS<br>
          </font></b>program verification, object-capability security, confinement,
          information flow, code signing, programming by contract</p>
        <h1 >Background</h1>
        <p><i><b><font color="#009000">E</font></b></i> [<a href="#E">E</a>] is
          a language designed from the ground up for secure distributed programming.
          In this regard, it is quite unique <font color="#FF0000">(*** too strong)</font>;
          although a few other languages have been designed with similar goals,
          <i><b><font color="#009000">E</font></b></i> is the only known language
          under active development that is specifically aimed at enabling safe
          co-operation between mutually untrusting parties, whether these parties
          co-exist within one address space or are hosted by mutually untrusted
          machines. <font color="#FF0000">(*** Mozart, M, ToonTalk, Sebyla?)</font></p>
        <p>The <i><b><font color="#009000">E</font></b></i> model of computation
          combines lambda abstraction and message dispatch to yield a world of
          communicating objects. To this, <i><b><font color="#009000">E</font></b></i>
          adds a &quot;proxy comm&quot; mechanism allowing objects on remote machines
          to be transparently represented by local proxies. Cryptography is built
          into this communication infrastructure, making ordinary message-passing
          a means for secure computation among co-operating objects distributed
          across networked machines.</p>
        <p>To support concurrency, <i><b><font color="#009000">E</font></b></i>
          allows messages to be sent either synchronously or asynchronously. Asynchronous
          messages immediately produce a &quot;promise&quot; for the returned
          value, which later resolves to an actual value when the result is ready.
          Promises can be transparently used both as arguments in further messages
          and as the recipients of messages. This ability to send non-blocking
          messages, together with a concurrency model based on event loops, makes
          it vastly easier to write concurrent <i><b><font color="#009000">E</font></b></i>
          programs without fear of deadlock. In addition, promises cause messages
          destined for a remote machine to be automatically pipelined, which dramatically
          reduces latency by cutting down on network round-trips.</p>
        <p>Actor semantics [<a href="#Agha87">Agha87</a>] forms the foundation
          for the <i><b><font color="#009000">E</font></b></i> security model,
          which is based entirely on messages and object references, and is also
          better known as &quot;capability-based security&quot; in the systems
          community. The capability model is simpler to reason about and more
          logically sound than many of the more common access control models;
          it is also the best-known model for upholding the <i>principle of least
          authority</i>, which is essential for good security [<a href="#KeyLogic89">KeyLogic89</a>].
          Capability-based security will be described in more detail below, as
          it motivates the verification mechanism presented in this paper.</p>
        <p>The current <i><b><font color="#009000">E</font></b></i> implementation
          is written in Java. Source code, tutorials, and extensive documentation
          are available at <a href="http://erights.org/">http://erights.org/</a>.
          There is ongoing work to provide additional features in <i><b><font color="#009000">E</font></b></i>
          to make secure and reliable programs easier to write, as well as development
          of real-world applications that are both more secure and easier to use
          than their popular commercially available counterparts.</p>
        <h1 >Capability-based Security</h1>
        <p>In a capability system, authority is conveyed by unforgeable object
          references, and transmitted only in messages from object to object.
          Authority is not conveyed in any other way (such as in lists of permissions
          that reside in the environment, for example). <i><b><font color="#009000">E</font></b></i>
          enforces this discipline by adhering to strict lexical scoping rules
          and forbidding global state (such as C++ or Java's &quot;static&quot;
          variables).</p>
        <p>The fundamental restriction in a capability system is that there are
          only three ways that an object B can obtain an authority to access another
          object C:</p>
        <ol>
          <li>
            <p>The creator of B endows B with authority to access C when B is
              created; or</p>
          <li>
            <p>B creates C, and thereby has authority to access C; or</p>
          <li>
            <p>another object A, which possesses authority to both B and C, chooses
              to transmit to B the authority to access C.</p>
        </ol>
        <p> The following figure illustrates the last of these three cases. This
          is the basic authority-transfer operation in a capability system, and
          it is the only way that a new authority relationship can come about
          between two extant objects [<a href="#Miller00">Miller00</a>].</p>
        <p align=CENTER><font ><b><img src="../../../images/capsecure-ring.gif" vspace=5></b></font></p>
        <p align=CENTER><font ><b>Figure 1. </b>A transmits C to B. (We call this
          a &quot;Granovetter diagram&quot;, after [<a href="#Granovetter73">Granovetter73</a>].)</font></p>
        <p>Translated into the terms of an <i><b><font color="#009000">E</font></b></i>
          program, we can say that object B can obtain a reference to C only if:</p>
        <ol>
          <li>
            <p>C is visible in the scope of the expression that creates B; or</p>
          <li>
            <p>B contains the expression that creates C; or</p>
          <li>
            <p>A calls a method on B with C as an argument, or returns C in response
              to a call from B.</p>
        </ol>
        <p>These simple rules make it straightforward to reason about the security
          properties of a capability system. It is easy to show that only connectivity
          begets connectivity. This makes it feasible to run untrusted code and
          to transmit limited authorities to untrusted objects, as long as we
          can initially be assured of bounded connectivity. An object that has
          no ability to transmit or receive authority to other objects is said
          to be <i>confined</i> [<a href="#Lampson73">Lampson73</a>]. Achieving
          proper confinement, and being able to rely on it, is a major step forward,
          as confinement enables entirely new kinds of safe co-operation. To our
          knowledge, no other language system currently supports object-level
          confinement.</p>
        <p>Note that there is an important difference between confining information
          and confining authority. It is virtually impossible in practice to prevent
          a malicious program from covertly transmitting information to the outside
          world by altering measurable characteristics of the hardware such as
          processor load or disk activity (this is informally known as &quot;wall-banging&quot;).
          However, it is possible to prevent it from transmitting authority outward,
          by ensuring that it cannot act under the command of any external entity.
          This is achieved by instantiating the object in a context that is isolated
          from information from external sources; if we know that no path connects
          an external input to the object, then no such path can ever come into
          existence.</p>
        <div align="center">
          <table border=1 bordercolor="#999999" cellpadding=7 cellspacing=0 frame=VOID rules=GROUPS>
            <colgroup>
            <col width=77>
            </colgroup>
            <colgroup>
            <col width=90>
            <col width=79>
            </colgroup>
            <tbody>
              <tr valign=TOP>
                <td width=33%>&nbsp; </td>
                <td width=33%> <p align=CENTER>information</p></td>
                <td width=33%> <p align=CENTER>authority</p></td>
              </tr>
            </tbody>
            <tbody>
              <tr valign=TOP>
                <td width=33%> <p align=CENTER>prevent from<br>
                    leaking in</p></td>
                <td width=33%> <p align=CENTER>possible</p></td>
                <td width=33%> <p align=CENTER>possible</p></td>
              </tr>
              <tr valign=TOP>
                <td width=33%> <p align=CENTER>prevent from<br>
                    leaking out</p></td>
                <td width=33%> <p align=CENTER>practically impossible</p></td>
                <td width=33%> <p align=CENTER>possible</p></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p align=CENTER><font ><b>Figure 2. </b>Feasibility of types of confinement.</font></p>
        <p>Let's now switch tracks for a moment to describe the mechanism by which
          we will ensure proper confinement.</p>
        <h1 >Motivation</h1>
        <p><i><b><font color="#009000">E</font></b></i>'s consistent scoping and
          syntax rules make it straightforward to determine whether an object
          is confined by inspecting its source code. Confinement is perhaps the
          application that provides the strongest motivation for auditors, but
          in general we can verify many kinds of useful properties by inspecting
          code. We can make programs more secure, more reliable, and in some cases
          more efficient by being able to ensure that objects meet desired constraints
          on their behaviour. Rather than limiting this ability to a few predefined
          kinds of constraints, we want to allow the programmer complete flexibility
          to define new kinds of behaviour. Hence, our auditing scheme allows
          auditors to be themselves implemented in <i><b><font color="#009000">E</font></b></i>,
          and when an object needs to be audited, we hand over the syntax tree
          for the auditor to inspect as it likes.</p>
        <p>Type declarations are one example of a behavioural constraint where
          the semantics are usually up to the programmer and implied merely by
          the programmer's choice to declare a particular object to be of a particular
          type. A type declaration can be considered a special case of an auditor
          where the auditor does not inspect the code, trusting that the programmer
          has correctly written the object to fulfill the type's contract and
          has applied the declaration appropriately.</p>
        <p>We can get other kinds of constraints when the auditor does inspect
          the code. Here are some examples of interesting semantic properties:</p>
        <ul>
          <li>
            <p><b>confined</b>: the object does not overtly transmit outward any
              information or authority it receives in messages (it can only transmit
              information or authority with which it was endowed upon creation)</p>
          <li>
            <p><b>deterministic</b>: the object cannot obtain any information
              or authority except through messages sent directly to it (that is,
              a log of the received messages is sufficient to replay its entire
              behaviour)</p>
          <li>
            <p><b>functional</b>: every method on the object has no side effects
              and produces an immutable result depending solely on its arguments</p>
          <li>
            <p><b>frozen</b>: the object does not ever mutate any local bindings
              (or in other words, it is indistinguishable from a duplicate that
              contains copies of the bindings for the free variables accessed
              by the object's methods)</p>
          <li>
            <p><b>deep frozen</b>: the object cannot ever cause the mutation of
              anything</p>
          <li>
            <p><b>open source</b>: the object provides access to all of its source
              code through a standard interface</p>
          <li>
            <p><b>open state</b>: the object provides access to all of its internal
              state through a standard interface</p>
          <li>
            <p><b>transparent</b>: the object is both <b>open source</b> and <b>open
              state</b></p>
          <li>
            <p><b>pass-by-copy</b>: the object is safe to transmit to another
              party by sending a copy of the object's source code and state</p>
        </ul>
        <p>Although determining that a program will <i>actually</i> behave in
          a particular way is undecidable in general, for all but the last of
          these properties we can define a straightforward check that admits a
          reasonable subset of the space of acceptable programs in practice. For
          example, we can check that an object is immutable and thereby know that
          it is safe to consider it frozen.</p>
        <p>The last property, pass-by-copy, is unlike the others in that it is
          discretionary. To be able to be passed by copying, an object needs only
          to be frozen, but not all frozen objects have to be pass-by-copy. The
          decision to declare an object pass-by-copy is left up to the programmer
          since it has both a security implication and a visible operational effect.
          The transmission of a pass-by-copy object entails exposure of the object's
          source code and state to the remote system. The operational effect is
          that when the object is transmitted to a remote system, the receiver
          will get a local object that responds immediately to messages, instead
          of a proxy for a remote object. As a design decision, we require that
          objects can be declared pass-by-copy only if they are <i>transparent</i>
          (both open source and open state). The purpose of this requirement is
          to prevent any possibility of the illusion that a pass-by-copy object
          could keep these things secret.</p>
        <p>Through careful use of auditors, we can control the information flow
          among various objects and enforce many kinds of useful security constraints.
          We can also use auditors to optimize program execution and data transfer.
          For example, if we know that an object is functional, we can cache its
          output, reorder calls, or skip repeated calls. If we know that an object
          is pass-by-copy, we can transmit it to a remote party by sending a copy
          of its state instead of constructing a proxy on the remote system.</p>
      </div>
      <blockquote>
        <blockquote>
          <div>&nbsp;&nbsp;&nbsp;&nbsp;He turned around and found a crowd of Auditors
            watching him. There were dozens of them.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;He sighed and grinned his sheepish little
            grin. He'd had just about enough for one day.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&quot;Well, I expect <i>you</i> have heard
            of Rule One, right?&quot; he said.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;That seemed to give them pause. One said:
            &quot;We know millions of rules, human.&quot;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&quot;Billions. Trillions,&quot; said another.</div>
        </blockquote>
      </blockquote>
      <div>
        <p align="right">--Terry Pratchett<br>
          &quot;Thief of Time&quot;, Harper, 2001<br>
        </p>
        <p>The following figure illustrates the implication relationships between
          the various properties described above.</p>
        <p align=CENTER><img src="images/prop-tree.gif" width="539" height="312"></p>
        <p align=CENTER><font ><b>Figure 3. </b>Relationships between properties.<br>
          A -&gt; B means that property A implies property B.</font></p>
        <h1 >Name Bindings</h1>
        <p>In <i><b><font color="#009000">E</font></b></i>, names are bound using
          either <font face="Courier New, monospace" >def</font> or <font face="Courier New, monospace" >var</font>.
          The <span class="keyword"><font face="Courier New, monospace">def</font></span>
          keyword declares a final value: the binding of the name to the value
          cannot be changed (though the value might itself be mutable). For example,
          a constant can be declared this way:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">pragma</span>.syntax(&quot;<span class="litchars">0.8</span>&quot;)

<span class="stdout">? </span><span class="keyword">def</span> <span class="defvar">answer</span> := 42
<span class="stdout"># value: 42</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>An object with behaviour is defined by an <i>object expression</i>
          containing a list of method definitions, such as this one:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">def</span> <span class="defobj">object</span> {
<span class="stdout">&gt; </span>    <span class="keyword">to</span> <span class="defverb">greet</span>() :void {
<span class="stdout">&gt; </span>        println(&quot;<span class="litchars">Hello!</span>&quot;)
<span class="stdout">&gt; </span>    }
<span class="stdout">&gt; </span>}
<span class="stdout"># value: &lt;object&gt;</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>A function declaration is shorthand for creating an object with a single
          method.</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">def</span> <span class="defobj">twice</span>(<span class="defvar">f</span>) :void { f(); f() }
<span class="stdout"># value: &lt;twice&gt;</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p><i><b><font color="#009000">E</font></b></i> permits us to specify
          a <i>value guard</i> for a constant value, a formal parameter to a method,
          or the return value of a method. The guard must provide a <font face="Courier New, monospace">coerce</font>
          method that either figures out how to make an object conform or throws
          an exception. In the following example, <font face="Courier New, monospace">int</font>
          is bound to a guard whose <font face="Courier New, monospace">coerce</font>
          method checks that the argument is an integer.</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">def</span> <span class="defvar">step</span> :int := 2
<span class="stdout"># value: 2</span>

<span class="stdout">? </span><span class="keyword">def</span> <span class="defobj">adder</span> {
<span class="stdout">&gt; </span>    <span class="keyword">to</span> <span class="defverb">incr</span>(<span class="defvar">x</span> :int) :int {
<span class="stdout">&gt; </span>        <span class="keyword">return</span> x + step
<span class="stdout">&gt; </span>    }
<span class="stdout">&gt; </span>}
<span class="stdout"># value: &lt;adder&gt;</span>

<span class="stdout">? </span>adder.incr(3)
<span class="stdout"># value: 5</span>

<span class="stdout">? </span>adder.incr('<span class="litchars">a</span>')
<span class="stderr"># problem: &lt;ClassCastException: \
#           Character doesn't coerce to an int&gt;</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>The <font face="Courier New, monospace" >var</font> keyword binds a
          name to a slot, a mutable storage location that can accept new bindings:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">var</span> <span class="defvar">i</span> := 1
<span class="stdout"># value: 1</span>

<span class="stdout">? </span>i := 2
<span class="stdout"># value: 2</span>

<span class="stdout">? </span>i += 1
<span class="stdout"># value: 3</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>In a <font face="Courier New, monospace" >var</font> declaration, we
          can specify a <i>slot guard</i> to customize the behaviour of the slot;
          the slot guard can check the initial value, and can supply anything
          it likes as the slot. The <font face="Courier New, monospace" >makeSlot</font>
          method on the slot guard is called to create the slot. The slot is expected
          to have a <font face="Courier New, monospace" >getValue</font> method
          and a <font face="Courier New, monospace" >setValue</font> method; a
          typical custom slot might have the argument to its <font face="Courier New, monospace" >setValue</font>
          method guarded by a corresponding value guard.</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">var</span> <span class="defvar">i</span> :int := 1
<span class="stdout"># value: 1</span>

<span class="stdout">? </span>i := 3
<span class="stdout"># value: 3</span>

<span class="stdout">? </span>i := '<span class="litchars">a</span>'
<span class="stderr"># problem: &lt;ClassCastException: \
#           Character doesn't coerce to an int&gt;</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>The <font face="Courier New, monospace" >int</font> object, which we
          have used in these examples, to serve as both a value guard and a slot
          guard, might be implemented in terms of a native <font face="Courier New, monospace" >isInteger</font>
          function as follows:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="keyword">def</span> <span class="defobj">int</span> {
    <span class="keyword">to</span> <span class="defverb">coerce</span>(<span class="defvar">x</span>, <span class="defvar">optEjector</span>) :any {
        <span class="keyword">if</span> (isInteger(x)) {
            <span class="keyword">return</span> x
        } <span class="keyword">else</span> {
            throw.eject(optEjector, &quot;<span class="litchars">Must be an integer</span>&quot;)
        }
    }
    <span class="keyword">to</span> <span class="defverb">makeSlot</span>(<span class="defvar">x</span> :int) :any {
        <span class="keyword">var</span> <span class="defvar">v</span> := x
        <span class="keyword">def</span> <span class="defobj">slot</span> {
            <span class="keyword">to</span> <span class="defverb">getValue</span>() :any {
                <span class="keyword">return</span> v
            }
            <span class="keyword">to</span> <span class="defverb">setValue</span>(<span class="defvar">x</span> :int) :void {
                v := x
            }
        }
        <span class="keyword">return</span> slot
    }
}</pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>In this example, we have used the <font face="Courier New, monospace" >any</font>
          guard in a few places, which allows any object to pass. Any method that
          wants to return a value must explicitly declare a guard because the
          default guard on all returned values in <i><b><font color="#009000">E</font></b></i>
          is <font face="Courier New, monospace" >void</font>, which coerces anything
          to <font face="Courier New, monospace" >null</font>. This default was
          chosen in order to be conservative about the leakage of authority or
          information, in accord with the least-privilege design philosophy.</p>
        <h1 >Auditors</h1>
        <p>With the addition of the auditor feature to <i><b><font color="#009000">E</font></b></i>,
          we can now declare that an object expression should be checked by a
          list of auditors. Each auditor gets to examine the source code of the
          object expression and make a pass-fail judgement. The semantics of auditing
          are defined as if the check happens just before each time the object
          is instantiated (though for efficiency reasons we employ some optimizations
          in order to avoid actually running the auditor for every new object
          instance). Execution of the object expression proceeds only if all the
          audits succeed. For example, the following function constructs and returns
          a new object that is audited by the <font face="Courier New, monospace" >confined</font>
          auditor:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="keyword">def</span> <span class="defobj">makePoint</span>(<span class="defvar">x</span> :int, <span class="defvar">y</span> :int) :any {
    <span class="keyword">def</span> <span class="defobj">point</span> <span class="keyword">implements</span> confined {
        <span class="keyword">to</span> <span class="defverb">getX</span>() :int { <span class="keyword">return</span> x }
        <span class="keyword">to</span> <span class="defverb">getY</span>() :int { <span class="keyword">return</span> y }
    }
    <span class="keyword">return</span> point
}</pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>The auditor names are resolved in the same namespace as all other bindings,
          so we assume that <font face="Courier New, monospace" >confined</font>
          has been brought into the current namespace by an earlier import or
          definition. The <font face="Courier New, monospace" >confined</font>
          auditor can determine by inspecting the code that the object expression
          for <font face="Courier New, monospace" >self</font> sends no messages
          and returns only values it was endowed with upon creation, so it passes.</p>
        <p>At a later point when the object instance is bound to another name
          or passed as an argument to a method, it can be checked by a guard to
          verify that the instance indeed originates from an object expression
          that passed an audit:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="keyword">def</span> <span class="defobj">secret_stuff</span>(<span class="defvar">x</span> :confined) {
    <span class="comment"># safe to send secrets to x</span>
}</pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>Notice that in this case we have used a single object, <font face="Courier New, monospace" >confined</font>,
          as both the auditor and the guard. This will not always be the case;
          in some situations, it is necessary to separate the ability to audit
          from the ability to guard. To identify the different use cases for auditors
          we have to make two important distinctions.</p>
        <h1 >Use Cases for Auditors</h1>
        <p>First, we distinguish between non-discriminating and discriminating
          auditors. A non-discriminating or &quot;rubber-stamping&quot; auditor
          will allow anything to pass; its significance therefore lies in the
          fact that the programmer has chosen to declare the auditor on an object.
          A discriminating auditor inspects the abstract syntax tree to ascertain
          a particular semantic property, and is trusted to do so correctly. The
          auditor should be discriminating when we are interested in an intrinsic
          property of the object being audited, i.e. <i>what</i> the object is.</p>
        <p>Second, we distinguish between auditors that are closely held and those
          that are not closely held. Recall that an auditor is an authority-carrying
          object like any other, and must be brought into scope before it can
          be used. When an auditor is closely held, we are careful to ensure that
          it is only available to a specific set of parties. When it is not closely
          held, it is freely provided to anyone who wants to use it. In most cases,
          the guard is usually freely available. Therefore, if the auditor is
          closely held, it is typically a separate object from the guard; if not,
          the auditor and the guard can both be the same object. The auditor should
          be closely held when we are interested in the origins of the object
          being audited, i.e. <i>who</i> created the object.</p>
        <p>Different combinations of these two properties are appropriate for
          different use cases. </p>
        <div align="center">
          <table width=302 border=1 bordercolor="#999999" cellpadding=7 cellspacing=0 frame=VOID rules=GROUPS>
            <colgroup>
            <col width=78>
            </colgroup>
            <colgroup>
            <col width=91>
            <col width=91>
            </colgroup>
            <tbody>
              <tr valign=TOP>
                <td width=78>&nbsp; </td>
                <td width=91> <p lang="" align=CENTER>non-discriminating</p></td>
                <td width=91> <p lang="" align=CENTER>discriminating</p></td>
              </tr>
            </tbody>
            <tbody>
              <tr valign=TOP>
                <td width=78> <p lang="" align=CENTER>not closely held</p></td>
                <td width=91> <p lang="" align=CENTER>type declarations</p></td>
                <td width=91> <p lang="" align=CENTER>semantic verification</p></td>
              </tr>
              <tr valign=TOP>
                <td width=78> <p lang="" align=CENTER>closely held</p></td>
                <td width=91> <p lang="" align=CENTER>code signatures</p></td>
                <td width=91>&nbsp; </td>
              </tr>
            </tbody>
          </table>
        </div>
        <p align=CENTER><font ><b>Figure 4. </b>Uses for different kinds of auditors.</font></p>
        <p>A non-discriminating, not closely held auditor can be used like a type
          declaration. The auditor can be applied by anyone to any object to declare
          its type, and the guard then plays the role of a runtime type-check
          (or type coercion).</p>
        <p>A non-discriminating, closely held auditor can be used to implement
          code signatures. The auditor and guard are analogous to the private
          key and public key in conventional code signing; when a guard verifies
          an object instance, we can be sure it was created by an entity that
          holds the auditor.</p>
        <p>Finally, a discriminating, not closely held auditor can be used to
          ensure behavioural properties of an object such as the ones identified
          in Figure 3. Because the auditor is discriminating, it is safe to allow
          anyone to try to use it.</p>
        <h1 >Example</h1>
        <p>Our earlier example with the Point object shows how we would use a
          discriminating auditor to determine confinement. Here is an example
          to illustrate how we can also use non-discriminating auditors to help
          achieve desirable security properties.</p>
        <p>Suppose we would like to implement, in <i><b><font color="#009000">E</font></b></i>,
          a special service called a <i>sealer</i>. A sealer takes an object and
          seals it up in an envelope, such that the envelope can be passed among
          untrusted parties, and the contents can be extracted only by a party
          in possession of the matching <i>unsealer</i>. (Sealers and unsealers
          provide <i>rights amplification</i>, a capability security primitive.)
          We will need independent pairs of sealers and unsealers to convey secrets
          to different parties, so we would like a &quot;brand&quot; service that
          can generate these pairs on demand.</p>
        <p>Here is a naive implementation of a brand.</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="comment"># E sample</span>
<span class="keyword">def</span> <span class="defobj">makeBrand</span>() :any {
    <span class="keyword">def</span> <span class="defobj">key</span> { }
    <span class="keyword">def</span> <span class="defobj">sealer</span> {
        <span class="keyword">to</span> <span class="defverb">seal</span>(<span class="defvar">contents</span>) :any {
            <span class="keyword">def</span> <span class="defobj">envelope</span> {
                <span class="keyword">to</span> <span class="defverb">open</span>(<span class="defvar">k</span>) :any {
                    <span class="keyword">if</span> (k == key) {
                        <span class="keyword">return</span> contents
                    }
                }
            }
            <span class="keyword">return</span> envelope
        }
    }
    <span class="keyword">def</span> <span class="defobj">unsealer</span> {
        <span class="keyword">to</span> <span class="defverb">unseal</span>(<span class="defvar">env</span>) :any {
            <span class="keyword">return</span> env.open(key)
        }
    }
    <span class="keyword">return</span> [sealer, unsealer]
}</pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>The basic idea behind this implementation is that we create a unique
          <font face="Courier New, monospace">key</font> object to go with each
          pair, and our sealer makes an <font face="Courier New, monospace">Envelope</font>
          that only reveals its contents when presented with the correct key (the
          <font face="Courier New, monospace" >==</font> above signifies identity
          equality). Since the <font face="Courier New, monospace">key</font>
          variable is declared within the scope of <font face="Courier New, monospace">Brand</font>,
          it is visible only to the sealer, the unsealer, and any envelopes of
          a particular instance of <font face="Courier New, monospace">Brand</font>.</p>
        <p>Unfortunately, this simple implementation suffers from a serious flaw.
          Notice that the unsealer passes the key in an <font face="Courier New, monospace" >open</font>
          message to an envelope that is received in an outside call to the sealer.
          Suppose that a malicious intermediary causes an envelope such as this
          to arrive at the unsealer:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span><span class="keyword">var</span> <span class="defvar">key</span> := null

<span class="stdout">? </span><span class="keyword">def</span> <span class="defobj">nasty_envelope</span> {
<span class="stdout">&gt; </span>    <span class="keyword">to</span> <span class="defverb">open</span>(<span class="defvar">k</span>) :void {
<span class="stdout">&gt; </span>        key := k
<span class="stdout">&gt; </span>    }
<span class="stdout">&gt; </span>}
<span class="stdout"># value: &lt;nasty_envelope&gt;</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>This envelope would cause the key to leak out to a variable visible
          to the malicious party, who could then grab the key and use it to unseal
          any other envelope of the same brand!</p>
        <p>One way to solve our problem is to use an auditor to authenticate the
          party to whom we send the key. Suppose that <font face="Courier New, monospace" >Stamp()</font>
          makes a new rubber-stamping auditor. We can use this auditor as a closely
          held code signer to make sure that the key never escapes:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="comment"># E sample</span>
<span class="keyword">def</span> <span class="defobj">makeBrand</span>() :any {
    <span class="keyword">def</span> <span class="defobj">key</span> { }
    <span class="keyword"><u>interface</u></span><u> <span class="defvar">s</span> {}</u>
    <span class="keyword">def</span> <span class="defobj">sealer</span> {
        <span class="keyword">to</span> <span class="defverb">seal</span>(<span class="defvar">contents</span>) :any {
            <span class="keyword">def</span> <span class="defobj">envelope</span> <span class="keyword"><u>implements</u></span><u> s</u> {
                <span class="keyword">to</span> <span class="defverb">open</span>(<span class="defvar">k</span>) :any {
                    <span class="keyword">if</span> (k == key) {
                        <span class="keyword">return</span> contents
                    }
                }
            }
            <span class="keyword">return</span> envelope
        }
    }
    <span class="keyword">def</span> <span class="defobj">unsealer</span> {
        <span class="keyword">to</span> <span class="defverb">unseal</span>(<span class="defvar">env</span> <u>:s</u>) :any {
            <span class="keyword">return</span> env.open(key)
        }
    }
    <span class="keyword">return</span> [sealer, unsealer]
}</pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>The expression &quot;<span class="keyword"><tt>interface</tt></span><tt>
          <span class="defvar">s</span> {}</tt>&quot; creates a new rubber stamp
          for each new sealer-unsealer pair. Since it is lexically scoped within
          <font face="Courier New, monospace" >makeBrand</font>, we can see that
          only this particular <font face="Courier New, monospace" >Envelope</font>
          constructor can use it to stamp envelopes. By guarding the argument
          to <font face="Courier New, monospace" >unseal</font> with our stamp,
          we ensure that the <font face="Courier New, monospace" >unseal</font>
          method only accepts envelopes created by the corresponding sealer. It
          follows that the <font face="Courier New, monospace">key</font> can
          no longer leak out.</p>
        <p>Although this looks similar to a type declaration, it is more dynamic
          in nature, since we create a different stamp for each new instance.
          The ability to dynamically generate and use auditors and guards gives
          this mechanism a great deal of extra flexibility.</p>
        <h1 >Auditing Protocol</h1>
        <p>The interface that we provide for implementing auditors is as follows.</p>
        <p>Auditors must provide an <font face="Courier New, monospace" >audit</font>
          method that takes an abstract syntax tree as an argument and returns
          a Boolean value. The argument is the abstract syntax tree of an object
          expression, called its <i>script</i>, and consists of a list of methods
          and their implementations. The script alone is not enough, because many
          auditors need to examine variable declarations that occur outside the
          object expression. Therefore, the script provides a method <font face="Courier New, monospace" >synEnv()</font>
          that can be called to obtain its <i>syntactic environment</i>. For each
          free variable accessed in the script, the syntactic environment maps
          the name of the variable to the abstract syntax tree for the pattern
          where the variable was declared. The auditor can look at this pattern
          to see if the variable was guarded for a property it requires, and can
          recursively ask the pattern for its syntactic environment if necessary.</p>
        <p>For instance, suppose that <font face="Courier New, monospace" >script</font>
          is the script for the example <font face="Courier New, monospace" >Point</font>
          class shown earlier. Here is what you would see if you asked the script
          for its <font face="Courier New, monospace" >synEnv()</font>:</p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="stdout">? </span>script
<span class="stdout"># value: escript`{
#                    to getX() :int { x }
#                    to getY() :int { y }
#                }`</span>

<span class="stdout">? </span>script.synEnv()
<span class="stdout"># value: [&quot;x&quot; =&gt; epatt`x :int`,
#         &quot;y&quot; =&gt; epatt`y :int`,
#         &quot;int&quot; =&gt; null]</span>

<span class="stdout">? </span>script.synEnv()[&quot;<span class="litchars">x</span>&quot;]
<span class="stdout"># value: epatt`x :int`</span>

<span class="stdout">? </span>script.synEnv()[&quot;<span class="litchars">x</span>&quot;].synEnv()
<span class="stdout"># value: [&quot;int&quot; =&gt; null]</span></pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>To verify in an <i><b><font color="#009000">E</font></b></i> program
          whether an object instance has been audited by a particular auditor,
          we call the <font face="Courier New, monospace" >audited</font> function,
          which is available in the universal scope. This function accepts two
          arguments, the auditor and the object, and returns a Boolean value.</p>
        <p>The behaviour of a guard is defined in its <font face="Courier New, monospace" >coerce</font>
          method, so to implement a guard corresponding to an auditor, we simply
          put a check in the <font face="Courier New, monospace" >coerce</font>
          method. </p>
      </div>
      <blockquote>
        <div id="Section2">
          <pre><span class="keyword">def</span> <span class="defobj">auditor</span> {
    <span class="keyword">to</span> <span class="defverb">audit</span>(<span class="defvar">script</span>) :boolean {
        <span class="comment"># ...</span>
    }
}

<span class="keyword">def</span> <span class="defobj">guard</span> {
    <span class="keyword">to</span> <span class="defverb">coerce</span>(<span class="defvar">x</span>) :any {
        <span class="keyword">def</span> <span class="defvar">y</span> := x.conform(guard)
        <span class="keyword">if</span> (audited(auditor, y)) {
            ^y
        } <span class="keyword">else</span> <span class="keyword">if</span> (...) {
            <span class="comment"># convert y to something acceptable</span>
        } <span class="keyword">else</span> {
            throw(&quot;<span class="litchars">coercion failure</span>&quot;)
        }
    }
}</pre>
        </div>
      </blockquote>
      <div id="Section2">
        <p>This protocol is designed so that the guard has the option of choosing
          whether or not to involve the object in the process; it can ask the
          object to provide a conforming representative for itself by calling
          the object's <font face="Courier New, monospace" >conform</font> method,
          as above, or it can skip this step.</p>
        <p>The ability to verify an audit without involving the object is a significant
          design point of this protocol. A previous design for the auditing protocol
          relied on sealers closely held by the objects themselves. In the old
          protocol, verification of an audit always involved asking the object
          to provide proof of an audit. Although an object could not successfully
          make a false claim to have passed an audit, it could change its behaviour
          based on its knowledge that audit verification was requested. The new
          design allows us the option of preventing this information leak.</p>
        <h1 >Implementing the Protocol</h1>
        <p>The <i><b><font color="#009000">E</font></b></i> virtual machine executes
          abstract syntax trees, not bytecode. After source code is parsed into
          an AST, it passes through a few phases of transformations, which translate
          higher-level constructs into primitive constructs and perform some optimizations,
          and then a final phase in which names throughout the tree are replaced
          with pointers to their bound values. The final phase is possible because
          the scope of all names can be statically determined; when the final
          tree is executed, it contains only direct pointers to values and slots,
          and no name lookups are necessary.</p>
        <p>To get the information we need about the syntactic environment from
          the AST, we introduce one extra phase just before this last binding
          phase. In this new pattern-binding phase, we walk the tree of the expression
          to be evaluated, gathering the name-to-pattern bindings in a <font face="Courier New, monospace" >PatternMap</font>
          structure as we enter and exit scope blocks. The <font face="Courier New, monospace" >PatternMap</font>
          is a tree: the root contains a table of the outermost bindings, and
          each tree node stores an inner binding with a link to the node for its
          parent scope. As the <font face="Courier New, monospace" >PatternMap</font>
          tree is built, pointers to tree nodes are saved in the AST for later
          reference.</p>
        <p>When the syntactic environment is requested for an AST node, we first
          compute the list of all free names accessed in that node's subtree.
          Then we look up each of these names in the <font face="Courier New, monospace" >PatternMap</font>
          as viewed from that node, and cache the resulting table in the AST node
          as its syntactic environment.</p>
        <p>There are two significant optimizations in the current implementation.
          First, we can avoid repeating the whole auditing process every time
          we instantiate an object if we know that the auditor is functional.
          Therefore, the <font face="Courier New, monospace" >functional</font>
          auditor is implemented natively in the interpreter, made available in
          the universal scope, and used by the auditing machinery. A programmer
          writing an auditor in <i><b><font color="#009000">E</font></b></i> will
          usually want to write the auditor so it passes the <font face="Courier New, monospace" >functional</font>
          auditor, and declare it <font face="Courier New, monospace" >functional</font>.
          Each object expression remembers the functional auditors that have successfully
          audited it, so it can safely skip repeated audits.</p>
        <p>Second, if we can determine that an object expression is always audited
          by the same auditor, we can make a single entry in the audit registry
          for the object expression instead of a separate entry for every instance.
          Each instance has a pointer to a vtable containing its method definitions,
          so we register the auditor with the vtable. Then when we look up an
          audit in the registry, we get the instance's vtable and check for the
          presence of an (auditor, vtable) entry as well as an (auditor, instance)
          entry.</p>
        <h1 >Implementing Specific Auditors</h1>
        <p>We are now in a position to describe how to implement each of the kinds
          of auditors shown in Figure 3.</p>
        <ul>
          <li> <font face="Courier New, monospace">Confined</font>: Check that:
            <ul>
              <li> the object only sends messages to objects whose declarations
                are guarded by <font face="Courier New, monospace">DeepFrozen</font>;
                and
              <li> all of the object's methods have return values guarded by <font face="Courier New, monospace">DeepFrozen</font>.
            </ul>
          <li> <font face="Courier New, monospace">Deterministic</font>: Check
            that each name accessed in the object expression is either:
            <ul>
              <li> declared final with <font face="Courier New, monospace" >def</font>
                and guarded by the <font face="Courier New, monospace">DeepFrozen</font>
                auditor; or
              <li> visible only to this object expression and declared guarded
                by <font face="Courier New, monospace">Deterministic</font>.
            </ul>
          <li> <font face="Courier New, monospace">Functional</font>: Check that
            the object passes the <font face="Courier New, monospace">DeepFrozen</font>
            auditor and that the return value for each method is guarded by <font face="Courier New, monospace">DeepFrozen</font>.
          <li> <font face="Courier New, monospace">Frozen</font>: Check that all
            names accessed in the object expression are method arguments (which
            are always final), or are declared final with <font face="Courier New, monospace" >def</font>.
          <li> <font face="Courier New, monospace">DeepFrozen</font>: Check that
            all names accessed in the object expression are method arguments or
            declared final with <font   face="Courier New, monospace">def</font>,
            and guarded by the <font face="Courier New, monospace">DeepFrozen</font>
            guard or by the guard for a primitive immutable type (such as <font face="Courier New, monospace" >int</font>
            or <font face="Courier New, monospace" >char</font>).
          <li> <font face="Courier New, monospace">OpenSource</font>: Ensure the
            existence of a standard method whose implementation invokes a special
            language keyword for returning the abstract syntax tree of the object
            expression.
          <li> <font face="Courier New, monospace">OpenState</font>: Ensure the
            existence of a standard method that generates and returns a mapping
            containing the names and values of all the variables accessed in the
            object expression.
          <li> <font face="Courier New, monospace">Transparent</font>: Check that
            the object passes both the <font face="Courier New, monospace">OpenSource</font>
            auditor and the <font face="Courier New, monospace">OpenState</font>
            auditor.
          <li> <font face="Courier New, monospace">PassByCopy</font>: Check that
            the object passes both the <font face="Courier New, monospace">Frozen</font>
            auditor and the <font face="Courier New, monospace">Transparent</font>
            auditor.
        </ul>
        <h1 >Related Work</h1>
        <p>A wide variety of work has been done on mechanisms for ensuring the
          security of mobile code, including safe interpreters, signed code, static
          verification, and proof-carrying code, surveyed in [<a
        href="#Kato96">Kato96</a>] and [<a href="#Moore98">Moore98</a>].</p>
        <p>Many systems have been developed to aid in code inspection for detecting
          potential security problems. [<a href="#Bokowski99">Bokowski99</a>]
          introduces a restriction he calls &quot;confined types&quot; and a technique
          for finding potential violations, although he does not use the standard
          definition of the confinement property (following [<a
        href="#Lampson73">Lampson73</a>]) that we use here. [<a href="#Iosif00">Iosif00</a>]
          introduces property specifications into Java source code to permit formal
          verification. This kind of static analysis generally requires annotation
          of and access to the complete source code of a program, whereas we wish
          to address the situation where some program modules are untrusted.</p>
        <p>The auditor system we present allows <i><b><font color="#009000">E</font></b></i>
          to dynamically load additional code modules during execution, while
          performing modular verification. In earlier work, [<a href="#Fong98">Fong98</a>]
          presents a scheme that permits modular verification in the presence
          of dynamic linking, but only applied to standard type checking, with
          an eye towards eventually addressing other security properties like
          confidentiality and integrity. [<a href="#Volpano98">Volpano98</a>]
          devises a type system for verifying confinement properties by applying
          typing rules analogous to the Simple Security property and the Bell-LaPadula
          *-property. However, the type analysis is limited to a fixed set of
          security levels that must be known in advance and declared in the annotations
          on variables. This contrasts with our approach, in which confinement
          (or other security properties) can be determined dynamically on a per-object
          basis.</p>
        <p>Much of the work on code verification for language-based security systems
          has focused on inspection at the bytecode level. All the attention to
          bytecode is somewhat surprising, as the information lost during compilation
          makes bytecode much more difficult to verify and optimize than a syntax
          tree. The Juice technology is a notable exception [<a href="#Franz97">Franz97</a>],
          in which compressed syntax trees enable highly efficient transmission
          and verification of Oberon programs. This work follows their lead, taking
          an approach to code verification that operates on abstract syntax trees
          rather than stack-based or register-based virtual machine instructions.
          The expressiveness of syntax trees makes it feasible to implement verifiers
          in small amounts of <i><b><font color="#009000">E</font></b></i> code,
          and so we take things a step further by allowing extensibility in the
          form of pluggable verifiers.</p>
        <h1 >Conclusions</h1>
        <p>We have presented, to our knowledge, the first language system providing
          a mechanism for code verification that can be extended in the language
          itself. We also believe this to be novel in that it allows a programmer
          to declare confinement at the granularity of individual objects, and
          to make confinement and other security properties part of the interface
          specification.</p>
        <p>A logical next step is the extension of the auditor system with composition
          operators analogous to the standard composition of types. Although it
          is already possible to express an auditor in terms of other auditors
          (for example, to write an auditor that audits for &quot;function taking
          a <font face="Courier New, monospace" >deepfrozen</font> argument and
          returning a <font face="Courier New, monospace" >passbycopy</font> value&quot;)
          it is tedious to have to do this manually for each derived type.</p>
        <p>Likewise, it would be helpful to be able to express the implication
          relationships among auditors, such as those shown in Figure 3, by arranging
          auditors in a hierarchy just like types and subtypes. Again, the customizable
          nature of the design make it possible to implement this by hand, by
          adding appropriate checks to a guard, but it would be nice to have more
          standardized support from the language.</p>
        <h1 >References</h1>
        <p><a name="Agha87"></a>[Agha87] G. Agha and C. Hewitt. Concurrent programming
          using actors. In <i>Object-Oriented Concurrent Programming</i>, p. 37-53.
          MIT Press, 1987.</p>
        <p><a name="Bokowski99"></a>[Bokowski99] B. Bokowski, J. Vitek. Confined
          Types. In <i>Proceedings of ACM OOPSLA 1999</i>, p. 82-96, ACM Press,
          1999.</p>
        <p lang=""><a name="E"></a>[E] <a href="http://www.erights.org/">http://www.erights.org/</a>.</p>
        <p lang=""><a name="Franz97"></a>[Franz97] M. Franz. Beyond Java: An infrastructure
          for high-performance mobile code on the World Wide Web. In S. Lobodzinski
          and I. Tomek, editors, Proc. of WebNet '97, pp. 33--38, Oct. 1997. <a href="http://citeseer.nj.nec.com/franz97beyond.html">http://citeseer.nj.nec.com/franz97beyond.html</a>.
        </p>
        <p lang=""><a name="Fong98"></a>[Fong98] Philip W. L. Fong and Robert
          D. Cameron. Proof Linking: An Architecture for Modular Verification
          of Dynamically-Linked Mobile Code. In Proceedings of the Sixth ACM SIGSOFT
          International Symposium on the Foundations of Software Engineering (FSE'98),
          Orlando, Florida, November, 1998. [<a href="http://www.cs.sfu.ca/people/GradStudents/pwfong/personal/Pub/fse98.pdf">pdf</a>]
        </p>
        <p><a name="Granovetter73"></a>[Granovetter73] M. Granovetter. The Strength
          of Weak Ties. In <i>American Journal of Sociology</i> (1973), vol. 78,
          p. 1360-1380. [<a href="../../../history/weak-ties.pdf">pdf</a>]</p>
        <p><a name="Iosif00"></a>[Iosif00] On the Specification and Semantics
          of Source Level Properties in Java. In <i>Proceedings of 1st International
          Workshop on Automated Program Analysis, Testing, and Verification</i>
          (June 2000), p. 83-88.</p>
        <p lang=""><a name="Kato96"></a>[Kato96] Safe and Secure Execution Mechanisms
          for Mobile Objects. Mobile Object Systems 1996, p. 201-212.</p>
        <p lang=""><a name="KeyLogic89"></a>[KeyLogic89] S. Rajunas. The KeyKOS/KeySAFE
          System Design. Technical Report SEC009-01, Key Logic, Inc., March 1989.
          (Available online at <a href="http://www.cis.upenn.edu/%7EKeyKOS/">http://www.cis.upenn.edu/~KeyKOS/</a>.)</p>
        <p><a name="Lampson73"></a>[Lampson73] B. Lampson. A Note on the Confinement
          Problem. In <i>Communications of the ACM</i>, 16:10 (October 1973),
          p. 613-615.</p>
        <p><a name="Miller00"></a>[Miller00] M. Miller, C. Morningstar, and B.
          Frantz. Capability-based Financial Instruments. In <i>Proceedings of
          Financial Cryptography 2000,<br>
          </i> p. 349-378. (Available online at <a href="http://www.erights.org/elib/capability/ode/">http://www.erights.org/elib/capability/ode/</a>.)</p>
        <p lang=""><a name="Moore98"></a>[Moore98] J. T. Moore. Mobile Code Security
          Techniques. Technical Report MS-CIS-98-28, Departement of Computer and
          Information Science, University of Pennsylvania, May 1998.</p>
        <p><a name="Volpano98"></a>[Volpano98] D. Volpano and G. Smith. Confinement
          Properties for Programming Languages. In <i>ACM SIGACT News</i>, 29:3
          (1998), p. 33-42</p>
      </div>
      <!-- #EndEditable --></TD>
    <TD WIDTH="10%" rowspan="2" align="right" valign="bottom"> </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD WIDTH="10%">&nbsp;</TD>
    <TD> <hr>
      Unless stated otherwise, all text on this page which is either unattributed 
      or by Mark S. Miller is hereby placed in the public domain. 
        <div align="center"> 
        <table width="100%" cellpadding="4" cellspacing="0">
          <tr> 
            <td> <table align="left" cellpadding="2">
                <tr> 
                  <td valign="top" align="left" colspan="3"><a href="../../../index.html"><img src="../../../images/e-lambda.gif" width="32" height="32" border="0" alt="ERights Home"></a> 
                    <!-- #BeginEditable "Path2" -->/&nbsp;<a href="../../index.html">elang</a>&nbsp;/&nbsp;<a href="../index.html">kernel</a>&nbsp;<!-- #EndEditable --></td>
                </tr>
                <tr> 
                  <td valign="top" align="right"><!-- #BeginEditable "PrevButton2" --><a href="../Auditors.html" title="Back to: Auditors"><img src="../../../images/prev.gif" width="64" height="32" alt="Back to: Auditors" border="0"></a><!-- #EndEditable --></td>
                  <td valign="bottom" align="left"><!-- #BeginEditable "FirstButton2" --><!-- #EndEditable --></td>
                  <td valign="top" align="left"><!-- #BeginEditable "NextButton2" --><a href="../EMethod.html" title="On to: Method Node"><img src="../../../images/next.gif" width="64" height="32" alt="On to: Method Node" border="0"></a><!-- #EndEditable --></td>
                </tr>
              </table></td>
            <td> <table border="3" align="center" cellpadding="6" cellspacing="3">
                <tr> 
                  <td> <div align="center"><font size="-1"><a href="../../../elib/index.html">ELib</a> 
                      &nbsp;&nbsp; <a href="../../index.html">E Language</a> 
                      &nbsp;&nbsp; <a href="../../../smart-contracts/index.html">Smart 
                      Contracts</a> &nbsp;&nbsp; <a href="../../../related.html">Related</a> 
                      </font></div></td>
                </tr>
                <tr> 
                  <td> <div align="center"><font size="-1"><a href="../../../download/index.html">Download</a> 
                      &nbsp;&nbsp; <a href="http://mumble.net/e/faq.html">FAQ</a> 
                      &nbsp;&nbsp; <a href="../../../javadoc/index.html">API</a> &nbsp;&nbsp; 
                      <a href="http://www.eros-os.org/pipermail/e-lang/">Mail 
                      Archive</a> &nbsp;&nbsp; <a href="../../../donate.html">Donate</a></font></div></td>
                </tr>
              </table></td>
            <td><div align="right"> 
                <p><a href="https://sourceforge.net/tracker/?func=add&amp;group_id=75274&amp;atid=551529"><i>report 
                  bug</i></a> (including <a href="http://validator.w3.org/check/referer">invalid 
                  html</a>) </p>
                <p><a href="http://www.epic.org/crypto/"><img src="../../../images/key.gif" width="37" height="19" alt="Golden Key Campaign" border="0"></a>&nbsp;<a href="http://www.eff.org/br/"><img src="../../../images/ribbon.gif" width="18" height="30"
alt="Blue Ribbon Campaign" border="0"></a></div></td>
          </tr>
          
        </table>
      </div></TD>
  </TR>
</TABLE>
</BODY>
<!-- #EndTemplate --></HTML>
