<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<!--last modified on Saturday, October 03, 1998 04:19 PM -->
<HTML><!-- #BeginTemplate "/Templates/pink.dwt" --><!-- DW6 -->
<HEAD>
<!-- #BeginEditable "doctitle" -->
<TITLE>From Capabilities To Financial Instruments</TITLE>
<!-- #EndEditable --> 
<meta http-equiv=content-type content="text/html; charset=UTF-8">
<meta name="Author" content="Mark S. Miller">
<link rel=author rev=made title="Mark S. Miller">
<META NAME="description" CONTENT="E: Cryptographic Capabilities for Distributed Smart Contracting">
<META NAME="keywords" CONTENT="p2p, p2p language, p2p computing, p2p objects, secure p2p, p2p capabilities, object oriented p2p,
  capability-based p2p, Capability Security, Capabilities, Cryptography, Distributed Objects, Distributed
  Language, Distributed Capabilities, Lambda Calculus, Scripting Language, Distributed Language, Persistent
  Language, Persistent Capabilities, Persistent Objects, Java Shell, Capability Shell, Scripting Java, Smart
  Contracting, Agoric E-Commerce, Open Source, Message pipelining, quasi literal, vat, event loop, granovetter diagram ">
<link rel="stylesheet" href="../../../erights.css" type="text/css">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFEEDD" LINK="#0000FF" VLINK="#800080">
<TABLE BORDER="0" width="100%">
  <TR VALIGN="TOP"> 
    <TD WIDTH="10%">&nbsp; </TD>
    <TD> <TABLE BORDER="0" WIDTH="100%">
        <TR> 
          <TD ALIGN="LEFT" valign="top"> <table cellpadding="2">
              <tr> 
                <td valign="top" align="left" colspan="3"><a href="../../../index.html"><img src="../../../images/e-lambda.gif" width="32" height="32" border="0" alt="ERights Home"></a> 
                  <!-- #BeginEditable "Path" -->/&nbsp;<a href="../../index.html">elib</a>&nbsp;/&nbsp;<a href="../index.html">capability</a>&nbsp;/&nbsp;<a href="index.html">ode</a>&nbsp;<!-- #EndEditable --></td>
              </tr>
              <tr> 
                <td valign="top" align="right"><!-- #BeginEditable "PrevButton" --><a href="ode-game.html" title="Back to: As Game"><img src="../../../images/prev.gif" width="64" height="32" alt="Back to: As Game" border="0"></a><!-- #EndEditable --></td>
                <td valign="bottom" align="left"><!-- #BeginEditable "FirstButton" --><!-- #EndEditable --></td>
                <td valign="top" align="left"><!-- #BeginEditable "NextButton" --><a href="ode-ack.html" title="On to: Acknowledgements"><img src="../../../images/next.gif" width="64" height="32" alt="On to: Acknowledgements" border="0"></a><!-- #EndEditable --></td>
              </tr>
            </table></TD>
          <TD rowspan="2" ALIGN="RIGHT"> <P ALIGN="RIGHT"><FONT SIZE="7"><!-- #BeginEditable "BigTitle" --><FONT SIZE="7"><font size="7"><b><font size="6">From
              Capabilities To</font><br>
              Financial Instruments</b></font></FONT><!-- #EndEditable --></FONT> </TD>
        </TR>
        
      </TABLE>
      <hr> <!-- #BeginEditable "LongBody" -->
      <h2><a name="cows"></a>From Stuff to Financial Instruments and Smart Contracts</h2>
      <p>Real world markets started out with direct trade of physical objects.
        To oversimplify greatly, ownership usually went along with possession
        and use, and, because of the locality of matter, all three together were
        exclusive. The user interface was intuitive -- you knew what rights you
        had because you could see your stuff. For Alice to transfer ownership
        of a cow to Bob, Alice and Bob would move the cow's physical location
        from Alice's territory to Bob's. Both would then effortlessly have common
        knowledge that the transfer had occurred, and who had which cows. Absent
        theft, possession would be an adequate record of ownership. Cows were
        bearer instruments. <i>(There is some evidence that the first money was
        coins redeemable for cows [<a href="ode-references.html#Selgin88">Selgin88</a>].)</i>
        Over time, of course, more abstract rights were invented, as were more
        complex arrangements for their transfer, usually with ghastly user interfaces
        and more room for misunderstandings and disputes.</p>
      <p>A major aspect of the emergence of capitalism from feudalism was the
        rise of contract. By creating a contract, you could define and transfer
        an arbitrary bundle of rights. The complexity of trade could now bloom,
        unrestrained by the simple limits of physical matter. During the twentieth
        century, a great variety of financial instruments were invented. These
        instruments represent the discovery of many new kinds of rights, and ways
        of deriving these rights from more primitive rights. We should hope the
        growth of financial cryptography will only accelerate this trend. For
        this hope to be realized, we should seek not just the secure computational
        expression of the contracts representing existing instruments, but the
        creation of secure material from which similar new contracts can easily
        be built. Following Nick Szabo [<a href="ode-references.html#Szabo97">Szabo97</a>],
        we refer to a partially self-enforcing computational embodiment of a contract
        as a <i>smart contract</i>.</p>
      <p>To understand the job ahead of us, we start by classifying the characteristics
        of rights.</p>
      <h2><a name="taxonomy"></a>A Taxonomy of Kinds of Rights</h2>
      <p>By contrasting some of the rights and rights-transfer mechanisms we have
        already seen -- capability-passing <i>vs.</i> SPKI certificates <i>vs.</i>
        our example money -- we can start to develop a taxonomy of rights. <i>(Economics
        elaborates this taxonomy much more fully, but we will only present the
        subset relevant to this paper.)</i> </p>
      <table cellpadding="24">
        <tr>
          <th>&nbsp;</th>
          <th>Capabilities</th>
          <th>SPKI</th>
          <th>Example Purse-Money</th>
        </tr>
        <tr>
          <th colspan="4"> <hr> </th>
        </tr>
        <tr>
          <th valign="top"> shareable <i>vs.</i> exclusive </th>
          <td valign="top">Alice <i>shares</i> with Bob her right to access Carol.</td>
          <td valign="top">Issuer <i>shares</i> with Subject the authorization
            to the Resource.</td>
          <td valign="top">When Bob deposits the payment from Alice, he <i>knows
            he has excluded</i> anyone else from using that money.</td>
        </tr>
        <tr>
          <td colspan="4"> <p>In the capability case, if Alice drops the capability
              after passing it to Bob, Bob happens to have exclusive access to
              Carol, but this isn't an exclusive right since Bob is unable to
              know that he is the only one who has it.</p>
            In the real world, information is sharable and physical objects are
            exclusive.
            <hr> </td>
        </tr>
        <tr>
          <th> specific <i>vs. </i>fungible </th>
          <td valign="top">A capability designates a <i>specific</i> object.</td>
          <td valign="top">Authorization can be for specific objects, or for some
            number of units. </td>
          <td valign="top">Money is <i>fungible</i>, since we care only about
            quantity, not individual bills. </td>
        </tr>
        <tr>
          <td colspan="4"> In the real world, real estate is specific and barrels
            of (a given grade of) oil are fungible. Peaches in the supermarket
            are specific -- you buy the ones you pick out. Peaches ordered over
            Peapod are fungible -- you order only by quantity.
            <hr> </td>
        </tr>
        <tr>
          <th> opaque <i>vs.</i> assayable </th>
          <td valign="top">A capability is <i>opaque</i>, since from the capability
            alone all you can determine is what the designated object alleges
            about itself.</td>
          <td valign="top">An authorization can be read as well as used. Reading
            it may suffice to <i>assay</i> what value it would provide.</td>
          <td valign="top">Bob can reliably <i>assay</i> the amount in an alleged
            purse only by transferring into a purse he trusts.</td>
        </tr>
        <tr>
          <td colspan="4">Assayability is needed for trade, since you must be
            able to determine what you would be getting <i>before</i> deciding
            to purchase. However, exclusive rights can only be reliably assayed
            by actually obtaining exclusive access to them, since otherwise, after
            you've assayed them, someone else may gain the exclusive, cutting
            you out. Trade of exclusives may therefor require a trusted third
            party who can hold them in escrow.
            <hr> </td>
        </tr>
        <tr>
          <th> exercisable <i>vs.</i> symbolic </th>
          <td valign="top">A capability has value only because it can be <i>exercised</i>,
            by sending a message to the object it designates.</td>
          <td valign="top">An authorization may be for either or both.</td>
          <td valign="top">As with fiat money, our example money is purely <i>symbolic</i>,
            since one can't do anything with it other than transfer it further.</td>
        </tr>
        <tr>
          <td colspan="4">There are many goods that are both exercisable and have
            symbolic value. For example, gold is commonly used as a pure symbol
            of value, but gold is also used to create electronic hardware and
            decorative jewelry.
            <hr> </td>
        </tr>
      </table>
      <p>It is curious that our example money is so different from capabilities,
        when the money is trivially built out of capabilities. More puzzling is
        the transfer. Alice passed to Bob only a capability, which therefor had
        all the rights-transfer properties of our first column. However, by doing
        so, she also paid him money, which has all the properties of the last
        column. Unsurprisingly, to resolve this we have to think in terms of two
        levels of abstraction. We must understand how these levels relate to each
        other, but we must keep them distinct.</p>
      <p>At the capability level, Alice is <i>sharing</i> with Bob the <i>specific</i>
        right to (at the money level) gain an <i>exclusive</i> on 10 <i>fungible</i>
        units of a particular currency. At the moment when Bob's <tt>foo</tt>
        method binds the incoming purse to the <tt>payment</tt> parameter-variable,
        Bob is now (capability level) sharing with Alice this specific right.
        In the next statement, where Bob deposits the money into his own purse,
        he is <i>exercising</i> this right to gain an exclusive, and thereby obtaining
        exclusive rights.</p>
      <p>To discuss the instruments presented below, we need to exercise similar
        care in keeping the levels straight.</p>
      <h2><a name="options-intro"></a>Options</h2>
      <p>From the point of view of a buyer, an option is the right to buy or sell
        some amount of some underlying instrument, such as stock, for a fixed
        price, within a period of time. From the point of view of the seller (called
        an option-writer), it is an offer to sell or buy at a locked in price,
        where the offer expires at a future time. Here we deal only with a covered
        call option. <i>Call</i> means the option holder may buy the stock. <i>Covered</i>
        means that the option seller puts aside stock to cover the possible exercise
        of the option as long as the option is outstanding, ensuring that he has
        the stock to sell should the option holder exercise her rights to buy.</p>
      <p>Due to space limitations, the following is an idealization which nevertheless
        should present the essence of a covered call option as a smart contract.
        Assume the existence of a broker mutually trusted by the option buyer
        and seller. The option seller &quot;writes&quot; the contract by delivering
        to the broker the last four parameters of the <tt>makeCoveredCallOption</tt>
        below. (The first three parameters come from the broker.) The broker invokes
        a <tt>makeCoveredCallOption</tt> within a vat he is running (so the mutual
        trust of the contract-platform can be inherited from mutual trust in the
        broker), and delivers to the option buyer the resulting <tt>coveredCallOption</tt>.
        The option buyer can exercise the option, paying the exercise price and
        gaining the stock, by calling the <tt>exercise</tt> method before the
        deadline has expired.</p>
      <p>Among the simplifications: </p>
      <ul>
        <li>
          <p>This protocol assumes share ownership is handled using the same code
            we've been using for money. This seems plausible, as stock ownership
            is also exclusive, fungible, and assayable. However, it is also exercisable
            -- by voting and collecting dividends [<a href="ode-references.html#MacKenzie99">MacKenzie99</a>].
            While stock is put aside to cover a call, the owner loses the right
            to sell it, but, until the option is exercised, retains the exercise
            rights of the stock. The following code ignores this issue.</p>
        </li>
        <li>
          <p>We do not show the broker's role in the payment of the premium from
            the buyer to the writer to pay for the initial purchase of the option.
            A realistic broker might escrow both the stock from the writer and
            the premium from the buyer, and only once both are successfully escrowed,
            then release the premium to the writer and the derived option to the
            buyer. The code implementing this logic is properly separate from
            the logic of the option itself.</p>
        </li>
        <li>
          <p>We ignore the broker's fees. A realistic broker may charge the buyer
            for setting up the option, and charge the writer when the option is
            exercised.</p>
        </li>
        <li>
          <p>The options normally traded are not <i>covered</i>. Rather, real
            world brokers absorb some of the risk that the writer may not be able
            to provide the stock when the buyer exercises. Brokers then partially
            mitigate these risks via complex contracts with the writers, involving
            margin calls and such. To understand such complex networks of contracts,
            we should start by first understanding the much simpler <i>covered</i>
            contracts we show here.</p>
        </li>
        <li>
          <p>Again due to space limitations, the following code ignores distribution
            and concurrency issues.</p>
        </li>
      </ul>
      <p>The only abstraction used below that is not yet explained is <i>timer</i>.
        <tt>timer</tt> provides access to real-world time. Its relevant operations
        are:</p>
      <blockquote>
        <table cellpadding="4">
          <tr>
            <td valign="top"> <pre>timer.whenPast(absMillis, thunk)</pre> </td>
            <td>&nbsp;</td>
            <td>This tells the timer to call <tt>thunk()</tt> after at least <tt>absMillis</tt>
              milliseconds have past since the epoch. (A thunk is a no-argument
              procedure, such as <tt>cancel()</tt>, defined below.)</td>
          </tr>
          <tr>
            <td valign="top"> <pre>timer.now()</pre> </td>
            <td>&nbsp;</td>
            <td>What's the current time?</td>
          </tr>
          <tr>
            <td valign="top"> <pre>timer.date(time)</pre> </td>
            <td>&nbsp;</td>
            <td>Returns a readable date string representing <tt>time</tt></td>
          </tr>
        </table>
      </blockquote>
      <p>In a typical object system, such a timer service might be globally accessible,
        but this would violate the capability constraints. No amount of internal
        computation would enable an object to determine the time, so access to
        time gives the object the ability to be affected by the outside world.
        By making this access into a first class object, we can instead supply
        other sources of time, as would be required, e.g., for deterministic replay.</p>
      <h2><a name="options-contract"></a>An Options Smart Contract</h2>
      <blockquote>
        <pre><span class="stdout">? </span><span class="keyword">pragma</span>.syntax(&quot;<span class="litchars">0.8</span>&quot;)</pre>
        <pre><span class="comment"># E sample</span>
<span class="keyword">def</span> <span class="defobj">makeCoveredCallOption</span>(<span class="defvar">timer</span>,                <span class="comment"># access to a real-world time service</span>
                          <span class="defvar">escrowedStock</span>,        <span class="comment"># reserves stock while offer is OPEN</span>
                          <span class="defvar">escrowedMoney</span>,        <span class="comment"># intermediate money-transfer purse</span>

                          <span class="comment"># The 3 args above are from broker. The 4 below  from options-writer</span>

                          <span class="defvar">stockSrc</span>,             <span class="comment"># provides the stock offered for sale</span>
                          <span class="defvar">deadline</span> :int,        <span class="comment"># time until which the offer is OPEN</span>
                          <span class="defvar">moneyDest</span>,            <span class="comment"># where the seller receives payment</span>
                          <span class="defvar">strikePrice</span> :int      <span class="comment"># price demanded  per share of stock</span>
) :any {
    <span class="keyword">def</span> <span class="defvar">numShares</span> :int := stockSrc.getBalance() <span class="comment"># how many shares are offered</span><font class="comment">
</font>    escrowedStock.deposit(numShares, stockSrc)  <span class="comment"># escrow all the shares in stockSrc
</span>
    <span class="keyword">var</span> <span class="defvar">state</span> := "<span class="litchars">OPEN</span>" <span class="comment"># one of OPEN, CLOSED, or CANCELLED</span>

    <span class="keyword">def</span> <span class="defobj">cancel</span>() :void {
        <span class="keyword">if</span> (state == "<span class="litchars">OPEN</span>") {
            stockSrc.deposit(numShares, escrowedStock) <span class="comment"># return stock to seller</span>
            state := "<span class="litchars">CANCELLED</span>"
        }
    }
    timer.whenPast(deadline, cancel) <span class="comment"># after deadline, call cancel()</span>

    <span class="keyword">def</span> <span class="defobj">coveredCallOption</span> {
        <span class="keyword">to</span> <span class="defverb">__printOn</span>(<span class="defvar">out</span>) :void {
            <span class="keyword">if</span> (state == "<span class="litchars">OPEN</span>") {
                <span class="comment"># converts to readable date string</span>
                <span class="keyword">def</span> <span class="defvar">expiration</span> := timer.date(deadline)
                out.print(`<span class="litchars">&lt;option to buy </span>$numShares<span class="litchars"> </span>` +
                          `<span class="litchars">for </span>$strikePrice per share<span class="litchars"> by </span>$expiration<span class="litchars">&gt;</span>`)
            } <span class="keyword">else</span> {
                out.print(`<span class="litchars">&lt;</span>$state<span class="litchars"> OPTION></span>`)
            }
        }
        <span class="keyword">to</span> <span class="defverb">getState</span>()       :any { <span class="keyword">return</span> state }
        <span class="keyword">to</span> <span class="defverb">getNumShares</span>()   :any { <span class="keyword">return</span> numShares }
        <span class="keyword">to</span> <span class="defverb">getStrikePrice</span>() :any { <span class="keyword">return</span> strikePrice }
        <span class="keyword">to</span> <span class="defverb">getDeadline</span>()    :any { <span class="keyword">return</span> deadline }

        <span class="keyword">to</span> <span class="defverb">exercise</span>(<span class="defvar">moneySrc</span>, <span class="defvar">stockDest</span>) :void {
            <span class="comment"># if not OPEN, throw &quot;not open&quot;</span>
            require(state == "<span class="litchars">OPEN</span>", <span class="keyword">thunk</span>{"<span class="litchars">not open</span>"})
            require(timer.now() &lt; deadline, <span class="keyword">thunk</span>{"<span class="litchars">too late</span>"})

            <span class="keyword">def</span> <span class="defvar">exerciseCost</span> := strikePrice * numShares
            escrowedMoney.deposit(exerciseCost, moneySrc)
            <span class="comment"># only if the call-writer can be  properly paid do we proceed</span><font class="comment">
</font>            state := "<span class="litchars">CLOSED</span>"
            <span class="keyword">try</span> {
                moneyDest.deposit(exerciseCost, escrowedMoney)
            } <span class="keyword">finally</span> {
                stockDest.deposit(numShares, escrowedStock)
            }
        }
    }
    <span class="keyword">return</span> coveredCallOption
}
</pre>
      </blockquote>
      <p>When the option is written, the stock in the purse provided by the option
        seller is put into escrow within the returned <tt>coveredCallOption</tt>,
        but the original purse is remembered in case the stock needs to be returned.
        The <tt>coveredCallOption</tt> and the <tt>cancel</tt> function share
        the same state. They can be seen as facets of the option-composite. Only
        the timer holds a reference to the <tt>cancel</tt> facet.</p>
      <p>If the option holder calls <tt>exercise</tt>, then the option will first
        attempt to deposit from the holder's <tt>moneySrc</tt> purse into the
        broker's empty <tt>escrowedMoney</tt> purse. <i>Only</i> if this succeeds
        does the option then transfer the money and stock from the purses in which
        they are escrowed into the writer's <tt>moneyDest</tt> purse and the holder's
        <tt>stockDest</tt> purse, respectively, and close the option. If the money
        is not successfully escrowed, the stock isn't transferred and the option
        remains open.</p>
      <p>Alternatively, if the deadline passes before the option is exercised,
        the escrowed stock is transferred back into the purse it came from and
        the option is cancelled.</p>
      <hr>
      <p><font size="-1">A qualification that may safely be skipped on a first
        reading:</font></p>
      <blockquote>
        <p><font size="-1">After this paper was published, Darius Bacon (darius-at-accesscom.com)
          rightly observed</font></p>
        <blockquote><font size="-1">This code has a vulnerability not mentioned
          here, I think. The options-writer could supply an evil [<tt>moneyDest</tt>]
          purse that accepts the money and then goes into a loop, preventing (or
          delaying) the buyer from getting the stock. This is possible because
          we only ever call the deposit method (and no other) on moneyDest, so
          moneyDest doesn't have to be a real purse to work -- it can be a wrapper
          around a real purse. If I'm not mistaken about this, it deserves at
          least a footnote, so picky bastards like me will know you have some
          answers.</font></blockquote>
        <p><font size="-1">Well Darius, you provided the footnote. Above we say
          &quot;due to space limitations, the following code ignores distribution
          and concurrency issues.&quot; Darius has indeed identified one of these
          concurrency issues. Although in other matters E has object granularity
          security, in matters of resource allocation E has at best vat granularity
          security. Among the objects within a vat, all resources are treated
          as a commons, enabling any to engage in a resource exhaustion attack
          as a form of denial of service attack, effective against other objects
          <i>in the same vat</i>. The simplest of these is the one Darius points
          out: There is no preemptive scheduling within a vat. If an object within
          the vat goes into an infinite loop, (in the absence of possible mechanisms
          like watchdog timers, which are not currently part of E, and will never
          be part of <i><b><font color="#009000">E</font></b></i>'s default configuration)
          then no other objects in that vat may ever again get to run again.</font></p>
        <p><font size="-1">However, in a realistic situation, for these very reasons,
          the <tt>moneyDest</tt> purse would be operating on the option writer's
          vat, or a least a vat other than the broker's vat. In this case, the
          above code would have to invoke the <tt>moneyDest</tt> purse with the
          eventual-send operator (&quot;<tt>&lt;-</tt>&quot;), which does not
          block the sending vat, but does provide the sending vat information
          about whether the operation succeeded. To deal with these issues in
          a partition tolerant fashion in fact requires a more complex protocol,
          such as the varieties of <a href="../../../smart-contracts/index.html#ERTP">ERTP</a>.
          A <a href="http://www.skyhunter.com/marcs/ewalnut.html#SEC18">description</a>
          of the eventual-send operator is well beyond the scope of this paper.
          </font> </p>
      </blockquote>
      <hr>
      <p>So what kind of a right have we created here? It is specific, but fungible
        options can be created. It isn't quite assayable, as the options holder
        cannot reliably tell which stock is being offered or which currency is
        demanded in exchange, but a more complex contract in the spirit of the
        above code can provide full assayability (given trust in the broker, of
        course). It is certainly exercisable! It also introduces a new dimension
        -- it is perishable rather than durable. The right to exercise spoils
        after a time.</p>
      <p>However, unlike a real-world option, it is sharable rather than exclusive.
        If Alice, the initial options holder, wishes to give Bob the option, Bob
        must assume that Alice still holds it, and therefor may still exercise
        it. As with the purse, they are sharing rights to manipulate exclusive
        rights. However, Bob cannot cope in the same manner, since the exclusive
        he wants now is not an exclusive on the underlying stock but an exclusive
        on the right to exercise the option. How can we make an exclusive option?</p>
      <p>We could try rewriting the above code to provide exclusivity as well,
        but the result would mix separate concerns into one abstraction. Better
        to add exclusivity to the above code by composition. Here's an adaptation
        of our money code to provide exclusivity for a single specific exercisable
        object:</p>
      <blockquote>
        <pre><span class="comment"># E sample</span>
<span class="keyword">def</span> <span class="defvar">makeBrandPair</span> := &lt;import:org.erights.e.elib.sealing.makeBrand&gt;

<span class="keyword">def</span> <span class="defobj">makeTitleCompany</span>(<span class="defvar">precious</span>, <span class="defvar">name</span>) :any {
    require(precious != null, <span class="keyword">thunk</span>{&quot;<span class="litchars">must provide an object</span>&quot;})
    <span class="keyword">def</span> [<span class="defvar">sealer</span>, <span class="defvar">unsealer</span>] := makeBrandPair(name)
    <span class="keyword">def</span> <span class="defobj">makePurse</span>(<span class="keyword">var</span> <span class="defvar">myPrecious</span>) :any {
        <span class="keyword">def</span> <span class="defobj">extract</span>() :any {
            require(myPrecious != null, <span class="keyword">thunk</span>{"<span class="litchars">empty</span>"})
            <span class="keyword">def</span> <span class="defvar">result</span> := myPrecious
            myPrecious := null
            <span class="keyword">return</span> result
        }
        <span class="keyword">def</span> <span class="defobj">purse</span> {
            <span class="keyword">to</span> <span class="defverb">__printOn</span>(<span class="defvar">out</span>) :void { out.print(`<span class="litchars">&lt;holds </span>$myPrecious<span class="litchars">&gt;</span>`) }
            <span class="keyword">to</span> <span class="defverb">isFull</span>()        :any { <span class="keyword">return</span> myPrecious != null }
            <span class="keyword">to</span> <span class="defverb">sprout</span>()        :any { <span class="keyword">return</span> makePurse(null) }
            <span class="keyword">to</span> <span class="defverb">getExtract</span>()    :any { <span class="keyword">return</span> sealer.seal(extract) }
            <span class="keyword">to</span> <span class="defverb">deposit</span>(<span class="defvar">src</span>)   :void {
                require(myPrecious == null, <span class="keyword">thunk</span>{"<span class="litchars">full</span>"})
                myPrecious := unsealer.unseal(src.getExtract())()
            }
            <span class="keyword">to</span> <span class="defverb">exercise</span>(<span class="defvar">verb</span>, <span class="defvar">args</span>) :any {
                <span class="keyword">return</span> E.call(myPrecious, verb, args)
            }
        }
        <span class="keyword">return</span> purse
    }
    <span class="keyword">return</span> makePurse(precious)
}
</pre>
      </blockquote>
      <p><i>(The </i><tt>E.call</tt><i> method enables one to dynamically (ie,
        reflectively) call any method of any object. For example, &quot;</i><tt>E.call(bob,&nbsp;&quot;<span class="litchars">foo</span>&quot;,&nbsp;[carol])</tt><i>&quot;
        has the same effect as &quot;</i><tt>bob.foo(carol)</tt><i>&quot;, but
        the </i><tt>E.call</tt><i> form allows computed verb-names and argument
        lists.)</i></p>
      <p>Given a single object, <tt>makeTitleCompany</tt> returns an initial purse
        holding this object. This purse is able to sprout other empty purses all
        able to hold only this object. Among such sibling purses, only one holds
        the object at a time. To move the object from one purse to another, one
        must have both purses.</p>
      <p>Such a purse is also an exercisable right. The holder of a purse may
        invoke any method on the underlying object. Care must be taken when programming
        objects that are intended to be held in such purses -- they should be
        designed not to return references to themselves as the result of any operation,
        as this would invalidate the exclusivity property.</p>
      <p>Once the broker creates the option, using the arguments from the option
        seller, it wouldn't release this non-exclusive options object to the first
        buyer, because the first buyer would then be unable to resell it. Instead,
        it would call <tt>makeTitleCompany(<i>option</i>, ...)</tt> and give the
        first buyer, Alice, the resulting purse. It would also hold on to this
        purse, indexed by a description of the option it created. </p>
      <p>When Bob wants to buy an exclusive on the option from Alice, Bob would
        first go to the broker to acquire an empty purse for holding the option
        that meets his description. The broker looks up the original purse from
        the description, and gives Bob a new sprout of this purse. When Alice
        gives Bob her option-holding purse, he deposits it into the purse he got
        from the broker. If this succeeds, he knows he now has an exclusive on
        the option to gain an exclusive on some amount of stock.</p>
      <h2><a name="composable-readable"></a>Composable Security, Readable Contracts</h2>
      <p>The kind of composition of abstractions demonstrated above is familiar
        in the object programming world, but without the security shown. The creation
        of cryptographic protocols for securely trading a variety of financial
        instruments is familiar in the financial cryptography world, but without
        the separation of concerns and easy composability shown. The best capability
        operating system work [<a href="ode-references.html#Hardy85">Hardy85</a>]
        does combine abstraction and security in this way, but without a notation
        to make the issues clear, and only when all parties fully trust one common
        platform.</p>
      <p>By using the Granovetter Operator as a bridge, we are able to apply strengths
        from all three worlds synergistically to the engineering of a single integrated
        system.</p>
      <p>Financial cryptography is a broad field encompassing a wide range of
        more specialized problem areas: cryptosystems, transactional protocols,
        user interface design, interface with existing financial and legal institutions,
        accounting, interface with legacy systems, creation of innovative financial
        instruments and institutions, the list is endless. However, the benefits
        achievable from specialization in any of these subfields have been limited
        by the costs of systems integration. It has hitherto been difficult to
        layer abstractions so that one can think clearly about one part of a system
        design without having to think about all the other parts of the system
        design simultaneously. This is especially troublesome in the development
        of financial systems where developers must proceed very cautiously due
        to the enormous potential cost of errors. It is our hope that the abstractions,
        tools and notation we have presented here will go a long way towards filling
        the need for the kinds of compositional power that will enable us to realize
        the tremendous promise of the world of electronic commerce.</p>
      <!-- #EndEditable --></TD>
    <TD WIDTH="10%" rowspan="2" align="right" valign="bottom"> </TD>
  </TR>
  <TR VALIGN="TOP"> 
    <TD WIDTH="10%">&nbsp;</TD>
    <TD> <hr>
      Unless stated otherwise, all text on this page which is either unattributed 
      or by Mark S. Miller is hereby placed in the public domain. 
        <div align="center"> 
        <table width="100%" cellpadding="4" cellspacing="0">
          <tr> 
            <td> <table align="left" cellpadding="2">
                <tr> 
                  <td valign="top" align="left" colspan="3"><a href="../../../index.html"><img src="../../../images/e-lambda.gif" width="32" height="32" border="0" alt="ERights Home"></a> 
                    <!-- #BeginEditable "Path2" -->/&nbsp;<a href="../../index.html">elib</a>&nbsp;/&nbsp;<a href="../index.html">capability</a>&nbsp;/&nbsp;<a href="index.html">ode</a>&nbsp;<!-- #EndEditable --></td>
                </tr>
                <tr> 
                  <td valign="top" align="right"><!-- #BeginEditable "PrevButton2" --><a href="ode-game.html" title="Back to: As Game"><img src="../../../images/prev.gif" width="64" height="32" alt="Back to: As Game" border="0"></a><!-- #EndEditable --></td>
                  <td valign="bottom" align="left"><!-- #BeginEditable "FirstButton2" --><!-- #EndEditable --></td>
                  <td valign="top" align="left"><!-- #BeginEditable "NextButton2" --><a href="ode-ack.html" title="On to: Acknowledgements"><img src="../../../images/next.gif" width="64" height="32" alt="On to: Acknowledgements" border="0"></a><!-- #EndEditable --></td>
                </tr>
              </table></td>
            <td> <table border="3" align="center" cellpadding="6" cellspacing="3">
                <tr> 
                  <td> <div align="center"><font size="-1"><a href="../../index.html">ELib</a> 
                      &nbsp;&nbsp; <a href="../../../elang/index.html">E Language</a> 
                      &nbsp;&nbsp; <a href="../../../smart-contracts/index.html">Smart 
                      Contracts</a> &nbsp;&nbsp; <a href="../../../related.html">Related</a> 
                      </font></div></td>
                </tr>
                <tr> 
                  <td> <div align="center"><font size="-1"><a href="../../../download/index.html">Download</a> 
                      &nbsp;&nbsp; <a href="http://mumble.net/e/faq.html">FAQ</a> 
                      &nbsp;&nbsp; <a href="../../../javadoc/index.html">API</a> &nbsp;&nbsp; 
                      <a href="http://www.eros-os.org/pipermail/e-lang/">Mail 
                      Archive</a> &nbsp;&nbsp; <a href="../../../donate.html">Donate</a></font></div></td>
                </tr>
              </table></td>
            <td><div align="right"> 
                <p><a href="https://sourceforge.net/tracker/?func=add&amp;group_id=75274&amp;atid=551529"><i>report 
                  bug</i></a> (including <a href="http://validator.w3.org/check/referer">invalid 
                  html</a>) </p>
                <p><a href="http://www.epic.org/crypto/"><img src="../../../images/key.gif" width="37" height="19" alt="Golden Key Campaign" border="0"></a>&nbsp;<a href="http://www.eff.org/br/"><img src="../../../images/ribbon.gif" width="18" height="30"
alt="Blue Ribbon Campaign" border="0"></a></div></td>
          </tr>
          
        </table>
      </div></TD>
  </TR>
</TABLE>
</BODY>
<!-- #EndTemplate --></HTML>
