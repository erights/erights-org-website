<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Nov 29 04:52:58 PST 2002 -->
<TITLE>
ELib API: Interface  EStream
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../javadoc/stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="#FFEEDD">
<p>&nbsp;
<h3>Streams Flow Through Conduits</h3>

 Let }}===}} be ascii art for a unidirectional conduit through which a stream
 flows. }}== is connector on the incoming side of a conduit where the back of
 the stream enters or is produced, corresponding to our <A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html"
><tt>OutStream</tt></A>. Such
 a conduit does not necessarily have an outgoing side.
 <p>
 ==}} is connector on the outgoing side or a conduit (spigot, faucet) where
 the front of the stream is consumed, corresponding to our <A HREF="../../../javadoc/org/erights/e/elib/eio/InStream.html"
><tt>InStream</tt></A>.
 Such a conduit does not necessarily have an incoming side.
 <p>
 InStreams and OutStreams may appear anywhere a stream of elements needs to be
 produced or consumed, such as writing to or reading from a file, in which
 case we can consider the file to be a conduit. Often InStreams and OutStreams
 will be used to wrap instances of java.io or java.nio classes, in which case
 the wrappers must turn these into conduits conforming to this spec. The
 notion of conduit is normally reified only by the connectors which serve
 as their facets -- there is no class "Conduit" (although an <A HREF="../../../javadoc/org/erights/e/elib/eio/EPipe.html"
><tt>EPipe</tt></A> is
 a kind of pure conduit, consisting of nothing but a buffer between its
 OutStream and InStream facets).


 <h3>Fallible Plumbing</h3>

 If conduit U has an InStream and conduit D has an OutStream, they may be hooked
 together, with U downstream from D, which we show as U=}}}}=D. U and D then
 represent the same stream of elements, except for time-lag (see below) and
 the possibility of failure. Conduits must be fail-stop -- they operate
 reliably until they permanently fail. Put another way, once a conduit finds
 it can no longer continue reliably, it must permanently and reliably fail.
 <p>
 To reduce cases in this spec, a remote reference to conduit is modeled as
 yet another section of pipe, so that a partition may be covered as a
 failure of this virtual conduit. (Once we have Unum support, a reference to
 a remote conduit may indeed always turn into a local reference to the
 corresponding end of a new section of vat-crossing pipe.)
 <p>
 (Note that this package provides no means for error recovery, such as
 retransmissions. Those errors that are recoverable by such means can be
 hidden at a lower level. This package reflects the irreducible issues, those
 that cannot be masked -- unrecoverable errors, flow control, partial
 ordering. Flush pressure, explained below, could be masked, but only at an
 unacceptable expense.)
 <p>
 Once a conduit fails, its OutStream must immediately report failure and stop
 accepting elements. If there are remaining elements in the conduit
 downstream of the failure (prior to the occurrence of the failure), then
 the InStream doesn't report failure (doesn't fail) until after these elements
 are consumed. The OutStream and InStream thereby fail at the same position in
 the stream, rather than at the same time.
 <p>
 If U closes or fails and D does not independently fail, then they will
 represent the same stream of elements followed by the same terminus.
 This is <i>downstream termination contagion</i>. If instead D fails
 independently, then D will represent some initial subsequence of U's stream
 followed by its own failure. If U does not independently fail, then it must
 eventually fail with D's terminal problem (upstream failure contagion).
 Although in some sense U's failure occurs later in the stream than D's, in
 the absence of other connectivity (see "A Join and Two Forks" below), this
 discrepancy is unobservable, as the remaining elements in U have nowhere to
 go and may be drained into the bitbucket.
 <p>
 In the absence of other connectivity, we need not consider the possibility
 of D independently closing. In our model, conduits may spontaneously fail,
 but they may not spontaneously close. For the purpose of reading this spec,
 a conduit implementation that actually does spontaneously close should be
 modeled as a regular conduit + a client of that conduit that tells it to
 close. This additional client counts as "other connectivity" and takes us
 to the "A Join and Two Forks" section below.
 <p>
 Once a connector is done (closed or failed) and the termination propogated,
 it is also permanently disconnected.


 <h3>Flush Pressure and Backpressure</h3>

 Two forces effect how the elements of a stream flow through a sequence of
 conduits: <i>flush pressure</i> and <i>backpressure</i>. Elements simply
 written into a conduit experience neither pressure. Flush pressure is caused
 by <A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html#flush()"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html#flush()"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html#flush()"
><tt>flush()</tt></A>, and provides a contingent guarantee of
 progress. Backpressure is caused by lack of incoming buffer space or a slow
 consumer, and brings about "flow control". (An additional kind, the normal
 <i>forward pressure</i> in which later writes into a buffer push out earlier
 elements which then proceed downstream, is a concern only of the implementor
 and need not affect this API.)
 <p>
 As with liquid streams, flush pressure causes progress and backpressure
 prevents progress. If there is flush pressure on an element, then there is
 flush pressure on all elements downstream of that element, transitively
 through all connected downstream conduits. Flush pressure is permamnent --
 once there is flush pressure on an element, that flush pressure remains
 on that element until the element emerges from the plumbing and is consumed.
 <p>
 If there is backpressure on an element, then there may be backpressure on
 some number elements upstream of that element, transitively through
 connected upstream conduits. (How far up backpressure propogates depends on
 the degree to which upstream buffers relieve the pressure). Backpressure
 comes and goes. Once the origin of backpressure stops exerting backpressure
 (ie, starts consuming), the absence of backpressure must eventually
 propogate upstream until some independent source of backpressure is
 encountered. Once a conduit is done (closed or failed), it stops exerting
 backpressure.
 <p>
 Unlike liquid streams, each of our pressures is either on or off, and
 reverse flow is not possible.<ul>
 <li>During the absence if either pressure, an element may make progress or
     it may <i>stagnate</i>. It may in fact stagnate forever, in which case
     the time-lag between U and D may be infinite.
 <li>So long as there is flush pressure and no backpressure, an element
     must eventually make progress. If there is never any backpressure, the
     time-lag between U and D must be finite.
 <li>So long as there is backpressure on an element, whether or not there is
     flush pressure as well, the element must stagnate -- it must not make
     progress. (XXX I'm not sure it means anything to obligate this.)
 </ul>


 <h3>A Join and Two Forks</h3>

 Conduits can be hooked together to form forks and joins as well, which we
 will not try to render in ascii art. (XXX Rather than try to have these
 fall out, we should instead require explicit Y connectors for these cases.
 I think I like that better, but here goes anyway...)

 <h4>Join</h4>

 If upstream conduits U1 and U2 are both feeding into downstream
 conduit D, then the relative order of elements from U1 must be preserved,
 and likewise from U2, but the order of elements in D may be any interleaving
 of these two orders. If you want "packet atomicity", then make streams
 in which these packets are the individual elements.
 <p>
 (U1 and U2 don't need to be InStreams. Either or both may simply be
 independent clients of OutStream D. Since one client vs multiple clients is
 in the eye of the beholder, this API must not require D to determine how
 many clients it has. This number is instead only in our heads as we state
 the properties of the API.)
 <p>
 The interleaving order may be unfair -- if both U1 and U2 always have data
 when D is ready, the interleaving may accept all of U1's stream before any
 of U2's. If U1 is infinite, U2 may be starved. As this story implies,
 backpressure in D may propogate upstream unfairly as well. Specializations
 of InStream or OutStream are free of course to state stronger contracts.
 <p>
 Flush pressure in U1 propogates as expected into D. Once flush pressure
 enters D, it applies to all prior elements in D even if they came from U2.
 <p>
 <b>Upstream failure contagion</b>: If D fails and U1 and/or U2
 don't themselves terminate independently, then U1 and/or U2 must eventually
 fail with D's terminal problem.
 <p>
 <b>Downstream termination contagion</b>: If U1 terminates and D doesn't
 terminate independently, then when U1's terminus enters D, D must terminate
 with this terminus. If this terminus is a failure, then it propogates back
 up to U2 as described above. If this terminus is a close, then U2 instead
 eventually fails with an <tt>EOFException</tt>.
 <p>
 We specify simple bidirectional contagion because it is easiest to implement
 and is the most fail-safe (since it is the most eager to fail), not because
 it is the most elegant. Should other contagion strategies be desired,
 adapters that, for example, filter out closes, can easily be built and
 inserted into the plumbing.

 <h4>The Multicast Fork:</h4>

 If upstream conduit U is connected to both downstream conduits D1 and D2 in
 a multicast manner, then all elements emerging from U arrive at both D1 and
 D2. Like the Unix "tee", the stream is duplicated, and one duplicate goes in
 each direction. Until someone terminates, D1 and D2 will receive elements
 from U in the same order, but not necessarily at the same time. Flush
 pressure in U also propogates to D1 and D2.
 <p>
 While D1 reports backpressure, U must stop the flow to D1 and may stop the
 flow to D2. U also may continue to feed D2 to the limits of its capacity to
 handle diverging positions.
 <p>
 Termination propogates both upstream and downstream again. Once one of these
 conduits terminate, they are all guaranteed to eventually terminate.
 <p>
 Joins and Multicasts may be composed. If both U1 and U2 feed both D1 and D2,
 then D1 and D2 will each receive and interleaving of the same two ordered
 streams, but not generally the same interleaving.

 <h4>The Splitting Fork:</h4>

 If upstream conduit X is connected to both downstream conduits Y and Z in a
 splitting manner, then all elements emerging from X arrive at one of Y and
 Z. We have no plans to support this at this time, so that's all for now.


 <h3>Synchrony and Transparency</h3>

 The above spec was careful to speak in terms of what must <i>eventually</i>
 happen. Regarding this subset of the spec, conduits are transparent up to
 failure. For example, if one adds another section of <A HREF="../../../javadoc/org/erights/e/elib/eio/EPipe.html"
><tt>EPipe</tt></A> onto an
 InStream or OutStream, then, by implication from the above spec, the remaining
 unconnected connector of the pipe inherits all the obligation of the
 original connector. If one uses the new connector instead of the original it
 can hardly make any difference. In this way, EPipes resemble E's promises,
 and conduits are to EPipes what references are to promises. This is why a
 future Unum-based implementation may be able to transparently insert new
 vat-crossing sections of pipe as needed.
 <p>
 But we also specify that connectors must have certain synchronous behaviors,
 and for these we don't require such transparency. See <A HREF="../../../javadoc/org/erights/e/elib/eio/EStream.html#available()"
><tt>available()</tt></A>.
<P>
<DL>
  <hr>
</DL>
<H3>
getElementType</H3>
<PRE>
public <A HREF="../../../javadoc/java/lang/Class.html"
></a><A HREF="../../../javadoc/java/lang/Class.html"
></a><A HREF="../../../javadoc/java/lang/Class.html"
>Class</A> <B>getElementType</B>()</PRE>
<DL>
<DD><b>Enabled:</b>  The type of elements that may appear in this stream.
 <p>
 If this class represents a <A HREF="../../../javadoc/java/lang/Class.html#isPrimitive()"
></a><A HREF="../../../javadoc/java/lang/Class.html#isPrimitive()"
></a><A HREF="../../../javadoc/java/lang/Class.html#isPrimitive()"
><tt>scalar type</tt></A>, then
 all elements must be instances of this type. Otherwise, the elements may
 be either instances of this type or null.
 <p>
 When connecting two streams, if the streams can determine from their
 respective elementTypes that no non-null element acceptable to one could
 be acceptable to the other, then they should fail to connect (reporting
 this as the reason why), rather than wait for an actual failure
 on transmitting an element. OTOH, if the types indicate that some
 element may be type compatible and others may not be, then connection
 must succeed, postponing failure until an actual incompatible element
 is encountered.
 <p>
 A later version of this API may allow a guard here instead of a class.</DL>
<HR>

<A NAME="available()"
><A NAME="available()"
><A NAME="available()"
><!-- --></A></A></A><H3>
available</H3>
<PRE>
public int <B>available</B>()</PRE>
<DL>
<DD><b>Enabled:</b>  How may elements can be immediately transferred (read or written)
 through this side of the stream?
 <p>
 On the reading side, how many elements are ready?
 <p>
 On the writing side, how much incoming buffer space is there?
 <p>
 If the stream is done (closed or failed) the answer is 0.</DL>
<HR>

<A NAME="onceAvailable(int)"
><A NAME="onceAvailable(int)"
><A NAME="onceAvailable(int)"
><!-- --></A></A></A><H3>
onceAvailable</H3>
<PRE>
public <A HREF="../../../javadoc/java/lang/Object.html"
></a><A HREF="../../../javadoc/java/lang/Object.html"
></a><A HREF="../../../javadoc/java/lang/Object.html"
>Object</A> <B>onceAvailable</B>(int&nbsp;size)</PRE>
<DL>
<DD><b>Enabled:</b>  Return a vow that's resolved once the stream seems ready to be
 reexamined.
 <p>
 Following a call to <tt>onceAvailable()</tt>, once at least one of the
 following conditions becomes true, the vow must eventually resolve
 according to one of them:<ul>
 <li>Once <tt>available() &gt;= 1</tt>, the vow may eventually resolve to
     <tt>false</tt>, meaning "not done yet".
 <li>Once <tt>available() &gt;= size</tt>, the vow must eventually
     resolve to <tt>false</tt>. Note that <tt>size</tt> must be
     <tt>&gt;= 1</tt>.
 <li>Once the stream closes, the vow must eventually resolve to
     <tt>true</tt>.
 <li>Once the stream fails, the vow must resolve to a reference broken by
     the terminal problem).
 </ul>
 Note that, by the time your code is notified of the resolution (for
 example, when the right side of your when/catch in invoked), the
 enabling condition may no longer apply and so will typically need to be
 rechecked.
 <p>
 Should any of the above conditions already apply at the time
 <tt>onceAvailable()</tt> is called, the corresponding answer must be
 immediately returned. Therefore, if the returned value is unresolved,
 this means that none of the above conditions apply at that moment.<DD><DL>
<DT><B>Parameters:</B><DD><tt>size</tt> - must be <tt>&gt;= 1</tt>.</DL>
</DD>
</DL>
<HR>

<A NAME="onceDone()"
><A NAME="onceDone()"
><A NAME="onceDone()"
><!-- --></A></A></A><H3>
onceDone</H3>
<PRE>
public <A HREF="../../../javadoc/java/lang/Object.html"
></a><A HREF="../../../javadoc/java/lang/Object.html"
></a><A HREF="../../../javadoc/java/lang/Object.html"
>Object</A> <B>onceDone</B>()</PRE>
<DL>
<DD><b>Enabled:</b>  Reveals the terminus -- the terminating condition after all the elements
 of the stream.
 <p>
 The terminus is either <tt>true</tt>, meaning close, or a reference
 broken by the terminal problem (an IOException).
 <p>
 If the stream is already done, then <tt>onceDone()</tt> returns the
 terminus immediately. Otherwise it returns a vow that must NOT resolve
 until the stream is done.
 <p>
 An immediate is-done check can then be written
 <pre>    Ref.isResolved(stream.onceDone())</pre>
 <p>
 On the reading side, the meaning of a <tt>onceDone()</tt> query is
 clear -- we're done after the last element has been read. The meaning
 on the writing side is analogous -- we're done after the last element
 has been written.</DL>
<HR>

<A NAME="fail(java.io.IOException)"
><A NAME="fail(java.io.IOException)"
><A NAME="fail(java.io.IOException)"
><!-- --></A></A></A><H3>
fail</H3>
<PRE>
public <A HREF="../../../javadoc/java/lang/Object.html"
></a><A HREF="../../../javadoc/java/lang/Object.html"
></a><A HREF="../../../javadoc/java/lang/Object.html"
>Object</A> <B>fail</B>(<A HREF="../../../javadoc/java/io/IOException.html"
></a><A HREF="../../../javadoc/java/io/IOException.html"
></a><A HREF="../../../javadoc/java/io/IOException.html"
>IOException</A>&nbsp;problem)</PRE>
<DL>
<DD><b>Enabled:</b>  Terminate the stream with failure, reporting problem as the reason.
 <p>
 A fail(..) implies a flush()</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/overview-summary.html"
></a><A HREF="../../../javadoc/overview-summary.html"
></a><A HREF="../../../javadoc/overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/org/erights/e/elib/eio/package-summary.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/package-summary.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/org/erights/e/elib/eio/class-use/EStream.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/class-use/EStream.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/class-use/EStream.html"
><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/org/erights/e/elib/eio/package-tree.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/package-tree.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/deprecated-list.html"
></a><A HREF="../../../javadoc/deprecated-list.html"
></a><A HREF="../../../javadoc/deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/index-files/index-1.html"
></a><A HREF="../../../javadoc/index-files/index-1.html"
></a><A HREF="../../../javadoc/index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../javadoc/help-doc.html"
></a><A HREF="../../../javadoc/help-doc.html"
></a><A HREF="../../../javadoc/help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../api-legend.html"
></a><A HREF="../../api-legend.html"
></a><A HREF="../../api-legend.html"
><FONT CLASS="NavBarFont1"><B>Legend</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../index.html"  target="_top"><img src="../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javadoc/org/erights/e/elib/eio/InStream.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/InStream.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/InStream.html"
><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/OutStream.html"
><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../javadoc/index.html" TARGET="_top"
></a><A HREF="../../../javadoc/index.html" TARGET="_top"
></a><A HREF="../../../javadoc/index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="../../../javadoc/org/erights/e/elib/eio/EStream.html" TARGET="_top"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/EStream.html" TARGET="_top"
></a><A HREF="../../../javadoc/org/erights/e/elib/eio/EStream.html" TARGET="_top"
><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary"
></a><A HREF="#field_summary"
></a><A HREF="#field_summary"
>FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary"
></a><A HREF="#method_summary"
></a><A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail"
></a><A HREF="#field_detail"
></a><A HREF="#field_detail"
>FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail"
></a><A HREF="#method_detail"
></a><A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<center>
  comments? <i>webmaster-at-erights.org</i>
</center>
</BODY>
</HTML>

