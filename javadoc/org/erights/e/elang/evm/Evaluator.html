<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Jul 02 22:16:15 PDT 2003 -->
<TITLE>
Evaluator (ELib API)
</TITLE>
<META NAME="keywords" CONTENT="org.erights.e.elang.evm.Evaluator,Evaluator interface">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Evaluator (ELib API)";
}
</SCRIPT>
<BODY BGCOLOR="#FFEEDD" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"
><A NAME="navbar_top"
><A NAME="navbar_top"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"
><A NAME="navbar_top_firstrow"
><A NAME="navbar_top_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../elib/legacy/api-legend.html"
><FONT CLASS="NavBarFont1"
><B><font color="#009000"><i>Legend</i></font></B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../../../../index.html"  target="_top"><img src="../../../../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Evaluator.html" TARGET="_top"
><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.erights.e.elang.evm</FONT>
<BR>
Interface Evaluator</H2>
<HR>
<DL>
<DT>public interface <B>Evaluator</B></DL>

<P>
<b><i><font color="#FF00FF">Untamed:</font></i></b>  Evaluates and matches <a href=
 "http://www.erights.org/elang/kernel/index.html"
 >Kernel-E</a> expressions and patterns explicitly, so that this
 evaluation can happen, for example, remotely.
 <p>
 Evaluators also support the E syntactic sugar<pre>
     meta.eval(evaluator, expr)

 and

     meta &lt;- eval(evaluator, expr)
 </pre>
 as a convenience for evaluating the expression in the lexical scope
 of the caller.
 <p>
 E is an expression/pattern language.  This means that execution
 proceeds by evaluating expressions in a lexical scope, and matching
 patterns in a lexical scope against a specimen (an arbitrary value
 which the pattern may match).  Expressions and patterns may
 recursively contain both expressions and patterns.  The result of
 matching a pattern against a specimen is not just an answer -- "Did
 the specimen match?" -- but also bindings of values (typically
 extracted from the specimen) to variables named in the pattern.
 Indeed, this is the only form of variable definition in E.
 <p>
 An E program is an fully ordered left-to-right tree of expressions
 and patterns, with a set of nested <a
 href="http://www.erights.org/elang/blocks/ifExpr.html"
 >scope boxes</a> statically imposed on this tree by particular
 types of expressions and patterns.  When a pattern defines a
 variable, this name is in scope left to right from the point of
 definition until the end of its containing scope box.
 <p>
 Putting it all together, a node (an expression or pattern) has two
 scope-based interfaces to the outside world: <p>
 <ul>
 <li><p><i>bindingsIn</i> are the those variables used freely by the
 node -- those that it uses but doesn't define, and that therefore
 must be in scope where the node starts.  We exempt from bindingsIn
 the
 <CODE>NonShadowable</CODE>
 elements of the safeScope.
 </p>
 <li><p><i>bindingsOut</i> are those variables defined by the node that
 are still in scope following the node, and that may be needed by
 code to the right of the node within the same enclosing scope box.
 In a static compilation context, this should only include variables
 that actually are used by a node to the right of the present
 node.</p>
 </ul>
 In one crucial way, the Evaluator is less general than the notion
 of evaluation defined by Kernel-E: To accomodate remote execution,
 bindingsIn and bindingsOut must represent only final variables,
 since they are a ConstMap mapping these names to values, rather
 than settable locations.  While this difference is visible to the
 Kernel-E programmer, it can be made largely invisible to the E
 programmer.  Except for variables recognized to fall into some
 special cases, the Deslotifying compilation phase transforms,
 for example, the mutable variable "foo" into corresponding final variable
 "foo__Slot", bound to an explicit Slot object holding the value of
 the "foo" variable.  Use of "foo" as a rValue then becomes
 "foo__Slot.getValue()" and assignment becomes
 "foo__Slot.setValue(newValue)".  Except for outer (ie, top-level) mutable
 scopes (used in the interactive read-eval-print loop, "rune"),
 all non-final variables and assignment statements could have been
 transformed away this way. (We chose not to in general in order to better
 support compilation, and because of the needs of the interactive
 read-eval-print loop.)  However, when transforming for use with an
 Evaluator, all the in and out variables must be so transformed.
 <p>
 The syntactic sugar <pre>
     meta.eval(evaluator, expr)
 </pre>
 expands into a call to <tt>evaluator</tt> to evaluate the provided
 expression in the lexical context of this sugar.  Assuming the
 evaluator evaluates the expression according to the normal rules,
 then the expression evaluation should have the same effects it
 normally would have had.  The Deslotifying transformation of the
 E compiler must turn all the variables in and out of expr into
 final variables, as explained above. For example, <pre>
     var x := 3
     def y := 7
     ... x ... x := 4 ... y ...
     ... meta.eval(visualizingEvaluator, x ** y =~ pow) ...
     ... pow ...

 expands to

     def x__Slot := settable.makeSlot(3)
     def y := 7
     ... x__Slot ... (x__Slot.setValue(4)) ... y ...
     def [pow, pow__Resolver] := Ref.promise()
     ... visualizingEvaluator.eval(e`x__Slot.getValue() ** y =~ pow`,
                                   ["x__Slot" => x__Slot, "y" => y],
                                   true,
                                   ["pow" => pow_Resolver]) ...
     ... pow ...
 </pre>
 If the "meta.eval(...)" occurs in a context where the value it
 evaluates to is statically seen as unneeded, the "true" above would
 instead be "false".
 <p>
 If <tt>pow</tt> were defined as <tt>var pow</tt>, it would be transformed
 into the final variable <tt>pow__Slot</tt>.
 <p>
 Similarly
 <pre>
     meta &lt;- eval(evaluator, expr)
 </pre>
 expands into an eventual send to evaluator to eventually evaluate
 the provided expression in the lexical context of this sugar. For
 example <pre>
     meta &lt;- eval(remoteEvaluator, def powOverThere(x) :any { x**2 })
     def y := powOverThere &lt;- (3)

 expands to

     def [powOverThere, powOverThere__Resolver] := Ref.promise()
     remoteEvaluator &lt;- eval(e`def powOverThere(x) :any { x**2 }`,
                             [].asMap(),
                             false,
                             ["powOverThere" => powOverThere__Resolver])
     def y := powOverThere &lt;- (3)
 </pre>
 The powOverThere function is defined on the remote machine or
 whatever, but is locally named "powOverThere".  If this machine is
 VatA and the remote machine is VatC, we could now hand powOverThere
 to an object on VatB, who would then obtain a reference directly
 connected to VatC.  If VatA then goes off-line, VatB would still be
 able to use powOverThere on VatC.
 <p>
 With the eventual form, the expression evaluates in the current
 lexical scope, just as if it were being implicitly evaluated, but
 it evaluates at a later time in its own turn, and potentially in
 another vat.  If this appears in a context where its value might be
 used, it evaluates to a promise for the outcome of evaluating the
 expression, and the third argument of the expansion would be
 "true".  Because of the delay, any Ejectors from the containing
 context will already be used up, so the expression cannot perform a
 non-local escape to an escape clause that has already exited
 (ie, Ejectors are dynamic-extent continuations).
 <p>
 If the evaluation is remote, then all bindings
 in and out will be as transformed by passage through the Pluribus.
 The non-obvious implication of this is that any use or assignment
 of any variable transformed by Deslotifying will fail if the
 resulting Slot is PassByProxy (the default).  When using "meta &lt;-
 eval(...)" to do remote evaluation, all in and out variables must
 either be final, or use Slot types that are PassByCopy or
 PassByConstruction (like the lamportSlot).
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark S. Miller</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"
><A NAME="method_summary"
><A NAME="method_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elang/evm/Evaluator.html#eval(org.erights.e.elang.evm.EExpr,org.erights.e.elib.tables.ConstMap,boolean,org.erights.e.elib.tables.ConstMap)"
>eval</A></B>(<A HREF="../../../../../org/erights/e/elang/evm/EExpr.html"
>EExpr</A>&nbsp;eExpr,
     <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsIn,
     boolean&nbsp;forValue,
     <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsOut)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Evaluates an E expression in a provided lexical scope.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elang/evm/Evaluator.html#evalToSingleton(org.erights.e.elang.evm.EExpr,org.erights.e.elib.tables.ConstMap,boolean,org.erights.e.elib.tables.ConstMap)"
>evalToSingleton</A></B>(<A HREF="../../../../../org/erights/e/elang/evm/EExpr.html"
>EExpr</A>&nbsp;eExpr,
                <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsIn,
                boolean&nbsp;forValue,
                <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsOut)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Just like eval(), except that, when evaluating for a value,
 evalToSingleton() returns a singleton list containing the
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elang/evm/Evaluator.html#matchBind(org.erights.e.elang.evm.Pattern,org.erights.e.elib.tables.ConstMap,boolean,org.erights.e.elib.tables.ConstMap,java.lang.Object)"
>matchBind</A></B>(<A HREF="../../../../../org/erights/e/elang/evm/Pattern.html"
>Pattern</A>&nbsp;pattern,
          <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsIn,
          boolean&nbsp;forTest,
          <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsOut,
          <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;specimen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Matches pattern against specimen, either failing or producing
 bindings.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"
><A NAME="method_detail"
><A NAME="method_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="eval(org.erights.e.elang.evm.EExpr,org.erights.e.elib.tables.ConstMap,boolean,org.erights.e.elib.tables.ConstMap)"
><A NAME="eval(org.erights.e.elang.evm.EExpr,%20org.erights.e.elib.tables.ConstMap,%20boolean,%20org.erights.e.elib.tables.ConstMap)"
><A NAME="eval(org.erights.e.elang.evm.EExpr, org.erights.e.elib.tables.ConstMap, boolean, org.erights.e.elib.tables.ConstMap)"
><!-- --></A></A></A><H3>
eval</H3>
<PRE>
public <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>eval</B>(<A HREF="../../../../../org/erights/e/elang/evm/EExpr.html"
>EExpr</A>&nbsp;eExpr,
                   <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsIn,
                   boolean&nbsp;forValue,
                   <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsOut)
            throws <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Evaluates an E expression in a provided lexical scope.
 <p>
 When invoked asynchronously ("&lt;-"), the invoker of eval()
 cannot distinguish between eval() evaluating to a broken
 reference as a value, vs eval() throwing a problem.  use
 evalToSingleton() when you want to avoid this ambiguity.
 (Note: This ambiguity will often be desired.  The "meta &lt;-
 eval(...)" purposely produces this ambiguity.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>eExpr</CODE> - The expression to be evaluated.<DD><CODE>bindingsIn</CODE> - Provides bindings for those variables
 used freely in eExpr, other than those defined in the
 safe scope (like "true").<DD><CODE>forValue</CODE> - Says whether anyone cares about the value this
 eExpr evaluates to.  If false, eval() should evaluate for
 effect only and return null.<DD><CODE>bindingsOut</CODE> - Provides a mapping from variable names to
 Resolvers for those variable names that eExpr defines, and that
 some expression in the successor scope uses.
<DT><B>Returns:</B><DD>If forValue is true, eval() returns the value that
 eExpr evaluates to.  If forValue is false, then eval() should
 return null, and its caller should ignore the return value,
 whatever it is.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE> - If eExpr exits non-locally, then eval()
 performs the same non-local exit.  The two kinds of non-local
 exit are throwing a problem (Throwable) and Ejecting.  Ejecting
 only works when the Ejector is still good, which can only
 happen when eval() is invoked synchronously.</DL>
</DD>
</DL>
<HR>

<A NAME="evalToSingleton(org.erights.e.elang.evm.EExpr,org.erights.e.elib.tables.ConstMap,boolean,org.erights.e.elib.tables.ConstMap)"
><A NAME="evalToSingleton(org.erights.e.elang.evm.EExpr,%20org.erights.e.elib.tables.ConstMap,%20boolean,%20org.erights.e.elib.tables.ConstMap)"
><A NAME="evalToSingleton(org.erights.e.elang.evm.EExpr, org.erights.e.elib.tables.ConstMap, boolean, org.erights.e.elib.tables.ConstMap)"
><!-- --></A></A></A><H3>
evalToSingleton</H3>
<PRE>
public <A HREF="../../../../../java/lang/Object.html"
>Object</A>[] <B>evalToSingleton</B>(<A HREF="../../../../../org/erights/e/elang/evm/EExpr.html"
>EExpr</A>&nbsp;eExpr,
                                <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsIn,
                                boolean&nbsp;forValue,
                                <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsOut)
                         throws <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Just like eval(), except that, when evaluating for a value,
 evalToSingleton() returns a singleton list containing the
 value.
 <p>
 This way an asynchronous invoker ("&lt;-") can distinguish
 between a successful evaluation to a broken reference as a
 value vs a thrown problem.
<P>
<DD><DL>

<DD><CODE><A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="matchBind(org.erights.e.elang.evm.Pattern,org.erights.e.elib.tables.ConstMap,boolean,org.erights.e.elib.tables.ConstMap,java.lang.Object)"
><A NAME="matchBind(org.erights.e.elang.evm.Pattern,%20org.erights.e.elib.tables.ConstMap,%20boolean,%20org.erights.e.elib.tables.ConstMap,%20java.lang.Object)"
><A NAME="matchBind(org.erights.e.elang.evm.Pattern, org.erights.e.elib.tables.ConstMap, boolean, org.erights.e.elib.tables.ConstMap, java.lang.Object)"
><!-- --></A></A></A><H3>
matchBind</H3>
<PRE>
public boolean <B>matchBind</B>(<A HREF="../../../../../org/erights/e/elang/evm/Pattern.html"
>Pattern</A>&nbsp;pattern,
                         <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsIn,
                         boolean&nbsp;forTest,
                         <A HREF="../../../../../org/erights/e/elib/tables/ConstMap.html"
>ConstMap</A>&nbsp;bindingsOut,
                         <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;specimen)
                  throws <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Matches pattern against specimen, either failing or producing
 bindings.
 <p>
 Unlike eval(), no syntactic sugar is currently defined for matchBind().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - The pattern to be matched against the specimen.<DD><CODE>bindingsIn</CODE> - Provides bindings for those variables
 used freely in pattern, other than those defined in the
 safe scope (like "true").<DD><CODE>forTest</CODE> - Says whether this should indicate failure by
 returning false.  If forTest, then on failure all the
 bindingsOut must be broken with a problem report explaining the
 reason for match failure.  If forTest is false, then the
 problem report is thrown on failure, and bindingsOut should be ignored.<DD><CODE>bindingsOut</CODE> - Provides a mapping from variable names to
 Resolvers for those variable names that pattern defines, and
 that some expression or pattern in the successor scope uses.
 The values of these 'out' variables are typically values
 extracted from specimen by matching.<DD><CODE>specimen</CODE> - The object to be matched against the pattern.
<DT><B>Returns:</B><DD>If forTest is true, matchBind() returns whether the
 match succeeded.  If forTest is false, then matchBind() only
 returns true, since if the match fails matchBind() throws
 rather than returning.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE> - If pattern exits non-locally, then
 matchBind() performs the same non-local exit.  The two
 kinds of non-local exit are throwing a problem (Throwable) and
 Ejecting.  Also, if forTest is false and the match fails,
 matchBind() throws a problem explaining the failure.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../elib/legacy/api-legend.html"
><FONT CLASS="NavBarFont1"
><B><font color="#009000"><i>Legend</i></font></B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../../../../index.html"  target="_top"><img src="../../../../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Evaluator.html" TARGET="_top"
><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<center>comments? <a href=http://www.blindpay.com/crit-me-now.cgi><img src=../../../../../../images/cmn.gif width=98 height=21 border=0 align=middle></a></center>
</BODY>
</HTML>

