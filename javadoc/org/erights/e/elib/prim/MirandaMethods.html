<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Jul 02 22:16:18 PDT 2003 -->
<TITLE>
MirandaMethods (ELib API)
</TITLE>
<META NAME="keywords" CONTENT="org.erights.e.elib.prim.MirandaMethods,MirandaMethods class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="MirandaMethods (ELib API)";
}
</SCRIPT>
<BODY BGCOLOR="#FFEEDD" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"
><A NAME="navbar_top"
><A NAME="navbar_top"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"
><A NAME="navbar_top_firstrow"
><A NAME="navbar_top_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../elib/legacy/api-legend.html"
><FONT CLASS="NavBarFont1"
><B><font color="#009000"><i>Legend</i></font></B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../../../../index.html"  target="_top"><img src="../../../../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/erights/e/elib/prim/Message.html"
><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/erights/e/elib/prim/OverloaderNode.html"
><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MirandaMethods.html" TARGET="_top"
><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.erights.e.elib.prim</FONT>
<BR>
Class MirandaMethods</H2>
<PRE>
<A HREF="../../../../../java/lang/Object.html"
>java.lang.Object</A>
  |
  +--<B>org.erights.e.elib.prim.MirandaMethods</B>
</PRE>
<HR>
<DL>
<DT>public class <B>MirandaMethods</B><DT>extends <A HREF="../../../../../java/lang/Object.html"
>Object</A></DL>

<P>
<b><i><font color="#FF00FF">Untamed:</font></i></b>  A sweetener defining default behavior for messages that may be e-called
 or e-sent to any methodical object.  These methods apply directly
 to null or a "new Object()".  Therefore, they must work when self
 is null.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark S. Miller</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"
><A NAME="field_summary"
><A NAME="field_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;<A HREF="../../../../../java/lang/Class.html"
>Class</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#NO_CLASSES"
>NO_CLASSES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"
><A NAME="constructor_summary"
><A NAME="constructor_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#MirandaMethods()"
>MirandaMethods</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevents instantiation</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"
><A NAME="method_summary"
><A NAME="method_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__conformTo(java.lang.Object,org.erights.e.elib.slot.ValueGuard)"
>__conformTo</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
            <A HREF="../../../../../org/erights/e/elib/slot/ValueGuard.html"
>ValueGuard</A>&nbsp;valueGuard)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  When a valueGuard doesn't succeed by itself at coercing an object,
 the valueGuard may enlists the object's aid in bring about a coercion
 it would find acceptable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/base/TypeDesc.html"
>TypeDesc</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__getAllegedType(java.lang.Object)"
>__getAllegedType</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Returns a description of the protocol this object alleges to implement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/sealing/SealedBox.html"
>SealedBox</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__optSealedDispatch(java.lang.Object,org.erights.e.elib.sealing.Brand)"
>__optSealedDispatch</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                    <A HREF="../../../../../org/erights/e/elib/sealing/Brand.html"
>Brand</A>&nbsp;brand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Generic object-level rights amplification protocol.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__optUncall(java.lang.Object)"
>__optUncall</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  This should return either <tt>null</tt> or a triple describing a call
 that, if performed, will create an object resembling this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__order(java.lang.Object,java.lang.String,java.lang.Object[])"
>__order</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
        <A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;nestedVerb,
        <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;nestedArgs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  For sending messages contingent on an earier success.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__printOn(java.lang.Object,org.erights.e.elib.oldeio.TextWriter)"
>__printOn</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
          <A HREF="../../../../../org/erights/e/elib/oldeio/TextWriter.html"
>TextWriter</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  For E, this is the method that should be widely overridden, rather
 than toString(), since composition via toString() cannot break
 cycles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__reactToLostClient(java.lang.Object,java.lang.Throwable)"
>__reactToLostClient</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                    <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;problem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  When someone was holding a partitionable eventual reference to this
 object, and it sufferes a partition, then this object is informed that
 one of its clients may no longer be able to talk to it, and why.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__respondsTo(java.lang.Object,java.lang.String,int)"
>__respondsTo</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
             <A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
             int&nbsp;arity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Does this object respond to messages described by verb/arity?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__whenBroken(java.lang.Object,java.lang.Object)"
>__whenBroken</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
             <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;reactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Used to implement "Ref whenBroken/2"; it should not be called
 directly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__whenMoreResolved(java.lang.Object,java.lang.Object)"
>__whenMoreResolved</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                   <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;reactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Used to implement when-catch and the "Ref whenResolved/2"; it should
 not be called directly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__yourself(java.lang.Object)"
>__yourself</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>The CapTP comm system no longer makes the use of this
             described above. If no one sees another need for this,
             perhaps we can get rid of it?</I></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"
><A NAME="methods_inherited_from_class_java.lang.Object"
><A NAME="methods_inherited_from_class_java.lang.Object"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="../../../../../java/lang/Object.html"
>Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../java/lang/Object.html#clone()"
>clone</A>, <A HREF="../../../../../java/lang/Object.html#equals(java.lang.Object)"
>equals</A>, <A HREF="../../../../../java/lang/Object.html#finalize()"
>finalize</A>, <A HREF="../../../../../java/lang/Object.html#getClass()"
>getClass</A>, <A HREF="../../../../../java/lang/Object.html#hashCode()"
>hashCode</A>, <A HREF="../../../../../java/lang/Object.html#notify()"
>notify</A>, <A HREF="../../../../../java/lang/Object.html#notifyAll()"
>notifyAll</A>, <A HREF="../../../../../java/lang/Object.html#toString()"
>toString</A>, <A HREF="../../../../../java/lang/Object.html#wait()"
>wait</A>, <A HREF="../../../../../java/lang/Object.html#wait(long)"
>wait</A>, <A HREF="../../../../../java/lang/Object.html#wait(long,int)"
>wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"
><A NAME="field_detail"
><A NAME="field_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="NO_CLASSES"
><A NAME="NO_CLASSES"
><A NAME="NO_CLASSES"
><!-- --></A></A></A><H3>
NO_CLASSES</H3>
<PRE>
private static final <A HREF="../../../../../java/lang/Class.html"
>Class</A>[] <B>NO_CLASSES</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"
><A NAME="constructor_detail"
><A NAME="constructor_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MirandaMethods()"
><A NAME="MirandaMethods()"
><A NAME="MirandaMethods()"
><!-- --></A></A></A><H3>
MirandaMethods</H3>
<PRE>
private <B>MirandaMethods</B>()</PRE>
<DL>
<DD>prevents instantiation
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"
><A NAME="method_detail"
><A NAME="method_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="__order(java.lang.Object,java.lang.String,java.lang.Object[])"
><A NAME="__order(java.lang.Object,%20java.lang.String,%20java.lang.Object[])"
><A NAME="__order(java.lang.Object, java.lang.String, java.lang.Object[])"
><!-- --></A></A></A><H3>
__order</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A>[] <B>__order</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                               <A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;nestedVerb,
                               <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;nestedArgs)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  For sending messages contingent on an earier success.
 <p>
 This method does the equivalent of
 <pre>
     to __order(self, nestedVerb, nestedArgs) :any {
         [E call(self, nestedVerb, nestedArg), self]
     }
 </pre>
 In other words, it calls the receiving object with the message
 <tt>nestedVerb(nestedArgs...)</tt>, and, if successful, returns
 a pair of the result of this call and the receiving object itself.
 <p>
 What is this for?  Consider the client code fragment
 <pre>
      databaseRcvr <- put(key1, value1)
      def value2Vow := databaseRcvr <- get(key2)
 </pre>
 E's <a
 href="http://www.erights.org/elib/concurrency/partial-order.html"
 >partial ordering semantics</a> ensure that put will be delivered
 before get is delivered.  That is often good enough.  But it is a
 weaker guarantee than that provided by the following sequential code
 <pre>
      database put(key1, value1)
      def value2Vow := database get(key2)
 </pre>
 In this code, not only will get only happen after put is delivered,
 get will only happen after put <i>succeeds</i>.  If put instead throws
 an exception, the get will never happen.  Often we want this effect.
 How can we acheive this with eventual-sends to eventual references?
 <p>
 When one wants to take an action contingent on the results of a
 previous action, the conventional E answer is to use a
 when-catch-finally expression
 <pre>
     def ackVow := databaseRcvr <- put(key1, value1)
     def value2Vow := when (ackVow) -> done(_) :any {
         databaseRcvr <- get(key2)
     } catch problem {
         throw(problem)
     }
 </pre>
 This is fine, as is probably the solution to be used by default for
 this situation.  However, it does force a round-trip between the get
 and put, and so loses the benefits of pipelining.  Using the __order
 message, we can get contingent execution + pipelining, at some cost in
 obscurity.  (Note: often, the cost of obscurity will dominate)
 <pre>
     def pairVow := databaseRcvr <- __order("put", [key1, value1])
     # If put's return value were interesting, we'd 'pairVow <- get(0)'
     def newDBRcvr := pairVow <- get(1)
     def value2Vow := newDBRcvr <- get(key2)
 </pre>
 If put throws, then pairVow will resolve directly to broken, so newDB
 will likewise resolve to broken, as will value2Vow
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__optUncall(java.lang.Object)"
><A NAME="__optUncall(java.lang.Object)"
><A NAME="__optUncall(java.lang.Object)"
><!-- --></A></A></A><H3>
__optUncall</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A>[] <B>__optUncall</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  This should return either <tt>null</tt> or a triple describing a call
 that, if performed, will create an object resembling this one.
 <p>
 Scalars (ints, float64s, chars, boolean, null) and bare Strings
 are <i>atomic</i>. <tt>__optUncall</tt> on an atomic objects return
 null, but atomic objects are still considered transparent.
 Objects which return non-null are <i>non-atomic</i> and
 <i>transparent</i>. Non-atomic objects that return null are
 <i>opaque</i>. Opaque objects may be <i>selectively transparent</i>
 to certain clients by using <A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__optSealedDispatch(java.lang.Object,org.erights.e.elib.sealing.Brand)"
><CODE>__optSealedDispatch(java.lang.Object, org.erights.e.elib.sealing.Brand)</CODE></A> as described
 there.
 <p>
 When a transpatent non-atomic object is <A HREF="../../../../../org/erights/e/elib/tables/Selfless.html"
><CODE>Selfless</CODE></A>, then the
 result of <tt>__optUncall</tt> is guaranteed to be accurate:
 It describes a call that, when performed, must result in this very same
 object, according to
 <CODE>E's "==" operation</CODE>. The Selfless
 auditor ensures that all Selfless objects are accurately self-describing
 in this way.
 <p>
 The uncall of a Selfless object is canonical, so if x and y are both
 Selfless, then
 <pre>    x == y iff x.__optUncall() == y.__optUncall()</pre>
 <p>
 Performing the call described by the uncall of a non-Selfless object
 generally creates whatever that object wished to create as its
 representative, but because it had to provide the ingredients, its
 representative could only be something it could have created. Therefore,
 the representative cannot convey any more authority than the original
 object itself has.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__optSealedDispatch(java.lang.Object,org.erights.e.elib.sealing.Brand)"
><A NAME="__optSealedDispatch(java.lang.Object,%20org.erights.e.elib.sealing.Brand)"
><A NAME="__optSealedDispatch(java.lang.Object, org.erights.e.elib.sealing.Brand)"
><!-- --></A></A></A><H3>
__optSealedDispatch</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/sealing/SealedBox.html"
>SealedBox</A> <B>__optSealedDispatch</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                                            <A HREF="../../../../../org/erights/e/elib/sealing/Brand.html"
>Brand</A>&nbsp;brand)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Generic object-level rights amplification protocol.
 <p>
 Dispatch on the brand much as one would dispatch on a message name.
 If we recognize the brand and we have the corresponding sealer, then
 we may return something meaningful inside a SealedBox sealed with that
 Sealer.  If we have nothing to return, given the meaning we associate
 with that brand as a request, then we return null.
 <p>
 Something meaningful?  Sounds strange.  See <a href=
 "http://www.eros-os.org/pipermail/e-lang/2002-May/006435.html"
 >[e-lang] Object coercion / adaptation</a> and the surrounding thread
 for more on the rationale for the design of this method.  Note that,
 at the time of that discussion, this method was named getOptMeta
 instead.
 <p>
 The default implementation: If self is Amplifiable, delegate to it.
 Otherwise, return null.
 <p>
 If this object isn't actually transparent, but if <tt>brand</tt>
 represents a party this object would like to reveal itself to (such as a
 serialization system implementing persistence for this object's
 subsystem), then this object can choose to return a SealedBox, sealed
 by the by the Sealer for that brand, containing the same triple that
 <A HREF="../../../../../org/erights/e/elib/prim/MirandaMethods.html#__optUncall(java.lang.Object)"
><CODE>__optUncall(java.lang.Object)</CODE></A> would otherwise have returned. By so doing, the
 object reveals its internals only to someone having the corresponding
 Unsealer.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__getAllegedType(java.lang.Object)"
><A NAME="__getAllegedType(java.lang.Object)"
><A NAME="__getAllegedType(java.lang.Object)"
><!-- --></A></A></A><H3>
__getAllegedType</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/base/TypeDesc.html"
>TypeDesc</A> <B>__getAllegedType</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Returns a description of the protocol this object alleges to implement.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__respondsTo(java.lang.Object,java.lang.String,int)"
><A NAME="__respondsTo(java.lang.Object,%20java.lang.String,%20int)"
><A NAME="__respondsTo(java.lang.Object, java.lang.String, int)"
><!-- --></A></A></A><H3>
__respondsTo</H3>
<PRE>
public static boolean <B>__respondsTo</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                                   <A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
                                   int&nbsp;arity)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Does this object respond to messages described by verb/arity?
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__printOn(java.lang.Object,org.erights.e.elib.oldeio.TextWriter)"
><A NAME="__printOn(java.lang.Object,%20org.erights.e.elib.oldeio.TextWriter)"
><A NAME="__printOn(java.lang.Object, org.erights.e.elib.oldeio.TextWriter)"
><!-- --></A></A></A><H3>
__printOn</H3>
<PRE>
public static void <B>__printOn</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                             <A HREF="../../../../../org/erights/e/elib/oldeio/TextWriter.html"
>TextWriter</A>&nbsp;out)
                      throws <A HREF="../../../../../java/io/IOException.html"
>IOException</A>,
                             <A HREF="../../../../../java/lang/NoSuchMethodException.html"
>NoSuchMethodException</A></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  For E, this is the method that should be widely overridden, rather
 than toString(), since composition via toString() cannot break
 cycles.  The Miranda method defaults to java-calling
 String.valueOf(self) and write()ing the result on out.
 String.valueOf(self) is java's null-safe form of self.toString();
<P>
<DD><DL>

<DD><CODE><A HREF="../../../../../java/io/IOException.html"
>IOException</A></CODE>
<DD><CODE><A HREF="../../../../../java/lang/NoSuchMethodException.html"
>NoSuchMethodException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="__reactToLostClient(java.lang.Object,java.lang.Throwable)"
><A NAME="__reactToLostClient(java.lang.Object,%20java.lang.Throwable)"
><A NAME="__reactToLostClient(java.lang.Object, java.lang.Throwable)"
><!-- --></A></A></A><H3>
__reactToLostClient</H3>
<PRE>
public static void <B>__reactToLostClient</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                                       <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;problem)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  When someone was holding a partitionable eventual reference to this
 object, and it sufferes a partition, then this object is informed that
 one of its clients may no longer be able to talk to it, and why.
 <p>
 The Miranda behavior is to do nothing, but objects may override this
 to provide DeadManSwitch behavior.  For example, a revoking facet of a
 revokable service may decide that if its client may no longer be able
 to talk to it, that it should auto-revoke.  However inconvenient this
 solution, it is failsafe.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__whenMoreResolved(java.lang.Object,java.lang.Object)"
><A NAME="__whenMoreResolved(java.lang.Object,%20java.lang.Object)"
><A NAME="__whenMoreResolved(java.lang.Object, java.lang.Object)"
><!-- --></A></A></A><H3>
__whenMoreResolved</H3>
<PRE>
public static void <B>__whenMoreResolved</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                                      <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;reactor)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Used to implement when-catch and the "Ref whenResolved/2"; it should
 not be called directly. <p>

 The Miranda behavior responds by doing 'reactor <- run(self)'.  If the
 reference never becomes resolved, the reactor is not invoked. <p>

 In the cooperative (non-malicious) case, the reactor will not be
 invoked more than once.

 When sent on a reference, once the reference becomes resolved the
 reactor will be invoked with the resolution.  Should the reactor be
 invoked with a non-broken reference, all earlier messages are
 guaranteed to have been successfully delivered. <p>

 Should the reference become broken, or should breakage prevent the
 reporting of fulfillment to the reactor, the reactor will be invoked
 with a broken reference.  The reactor may be invoked more than once.
 In particular, if the reference becomes fulfilled and then broken,
 the reactor may hear of either or both of these events.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><CODE>org.erights.e.elib.ref.Ref#whenBroken</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="__whenBroken(java.lang.Object,java.lang.Object)"
><A NAME="__whenBroken(java.lang.Object,%20java.lang.Object)"
><A NAME="__whenBroken(java.lang.Object, java.lang.Object)"
><!-- --></A></A></A><H3>
__whenBroken</H3>
<PRE>
public static void <B>__whenBroken</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                                <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;reactor)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Used to implement "Ref whenBroken/2"; it should not be called
 directly.
 <p>
 The Miranda behavior ignores the message, as only breakable ref
 implementations ever respond to this message.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><CODE>Ref.whenBroken/2</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="__yourself(java.lang.Object)"
><A NAME="__yourself(java.lang.Object)"
><A NAME="__yourself(java.lang.Object)"
><!-- --></A></A></A><H3>
__yourself</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>__yourself</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>The CapTP comm system no longer makes the use of this
             described above. If no one sees another need for this,
             perhaps we can get rid of it?</I>
<P>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  When invoked on a methodical object, the object should simply return
 itself.
 <p>
 Although the name and the semantics are borrowed from
 Smalltalk, the purpose is completely different.  This method is used
 by distributed three vat handoff to implement the poE ordering
 guarantees: When Alice sends to Bob a reference to Carol
 <pre>    E.sendOnly(bob, "foo", carol)</pre>
 when each is on a different machine, the encoding of Alice's Far
 reference to Carol instead encodes the value returned by
 <pre>    E.send(carol, "__yourself")</pre>
 Any messages sent to this result will only be received by Carol after
 Carol receives the "__yourself" message, and therefore after Carol has
 received all messages which precede the "youself" message.  This is
 true even if the messages sent to the result are sent from another
 machine, as would be the case in distributed three vat handoff.
 <p>
 Since all this results in a system which successfully implements poE,
 users of ELib other than captp should never need to invoke this method,
 and no one should ever need to override it. If we do make some miranda
 methods non-overridable, we would make __yourself/1 non-overridable.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="__conformTo(java.lang.Object,org.erights.e.elib.slot.ValueGuard)"
><A NAME="__conformTo(java.lang.Object,%20org.erights.e.elib.slot.ValueGuard)"
><A NAME="__conformTo(java.lang.Object, org.erights.e.elib.slot.ValueGuard)"
><!-- --></A></A></A><H3>
__conformTo</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>__conformTo</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;self,
                                 <A HREF="../../../../../org/erights/e/elib/slot/ValueGuard.html"
>ValueGuard</A>&nbsp;valueGuard)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  When a valueGuard doesn't succeed by itself at coercing an object,
 the valueGuard may enlists the object's aid in bring about a coercion
 it would find acceptable.
 <p>
 A valueGuard enlists the object's aid at the price of being
 <a href="http://www.sims.berkeley.edu/~ping/auditors/">Gozarian</a>.
 A Gozarian valueGuard wants to enlists the object's aid <i>because</i>
 it is ignorant of the kind of object it's dealing with, so a generic
 protocol is needed. That's why __conformTo/1 is provided as a
 MirandaMethod.
 <p>
 The valueGuard asks the object to conform to some valueGuard that the
 object may know about. Often this will be the valueGuard that's
 attempting the coercion. An object should attempt to return a
 representation of itself that the argument valueGuard would succeed in
 coercing. A requesting valueGuard should then try again on the result,
 but if this doesn't coerce, it should fail there rather than making
 further __conformTo/1 requests. This implies that it's the
 responsibility of the object's __conformTo/1 implementation to do any
 iteration needed for multi-step conversions.
 <p>
 The default (Miranda) implementation of __conformTo/1 just returns
 self.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../elib/legacy/api-legend.html"
><FONT CLASS="NavBarFont1"
><B><font color="#009000"><i>Legend</i></font></B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../../../../index.html"  target="_top"><img src="../../../../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/erights/e/elib/prim/Message.html"
><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/erights/e/elib/prim/OverloaderNode.html"
><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MirandaMethods.html" TARGET="_top"
><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<center>comments? <a href=http://www.blindpay.com/crit-me-now.cgi><img src=../../../../../../images/cmn.gif width=98 height=21 border=0 align=middle></a></center>
</BODY>
</HTML>

