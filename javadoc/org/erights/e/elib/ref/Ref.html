<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Jul 02 22:16:18 PDT 2003 -->
<TITLE>
Ref (ELib API)
</TITLE>
<META NAME="keywords" CONTENT="org.erights.e.elib.ref.Ref,Ref class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Ref (ELib API)";
}
</SCRIPT>
<BODY BGCOLOR="#FFEEDD" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"
><A NAME="navbar_top"
><A NAME="navbar_top"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"
><A NAME="navbar_top_firstrow"
><A NAME="navbar_top_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../elib/legacy/api-legend.html"
><FONT CLASS="NavBarFont1"
><B><font color="#009000"><i>Legend</i></font></B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../../../../index.html"  target="_top"><img src="../../../../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Redirector.html"
><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/RemotePromise.html"
><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Ref.html" TARGET="_top"
><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.erights.e.elib.ref</FONT>
<BR>
Class Ref</H2>
<PRE>
<A HREF="../../../../../java/lang/Object.html"
>java.lang.Object</A>
  |
  +--<B>org.erights.e.elib.ref.Ref</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../../org/erights/e/elib/sealing/Amplifiable.html"
>Amplifiable</A>, <A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../../org/erights/e/elib/ref/BufferingRef.html"
>BufferingRef</A>, <A HREF="../../../../../org/erights/e/elib/ref/DisconnectedRef.html"
>DisconnectedRef</A>, <A HREF="../../../../../org/erights/e/elib/ref/NearRef.html"
>NearRef</A>, <A HREF="../../../../../org/erights/e/elib/ref/Proxy.html"
>Proxy</A>, <A HREF="../../../../../org/erights/e/elib/ref/StemCell.html"
>StemCell</A>, <A HREF="../../../../../org/erights/e/elib/ref/SwitchableRef.html"
>SwitchableRef</A>, <A HREF="../../../../../org/erights/e/elib/ref/UnconnectedRef.html"
>UnconnectedRef</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>Ref</B><DT>extends <A HREF="../../../../../java/lang/Object.html"
>Object</A><DT>implements <A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></DL>

<P>
<b><i><font color="#009000">Safe:</font></i></b>  Objects that handle E eventual-send message delivery requests themselves.

 Represents a resolvable reference hopefully eventually designating
 some object. <p>

 Because Refs are seen by E only through the Ref protocol, any
 public methods that subclasses want to make visible should be static
 methods that take a 'self' instance as an argument, rather than instance
 methods. <p>

 A Ref is often a facet of a promise.  A promise is a composite
 consisting of a Ref as arrow tail, and often a resolver of some
 sort as arrow head.  Usually, the resolver will be of type
 Resolver, but not necessarily.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark S. Miller</DD>
<DT><B>See Also:</B><DD><a href="http://www.erights.org/elib/concurrency/refmech.html"
 >Reference Mechanics</a></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"
><A NAME="field_summary"
><A NAME="field_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/String.html"
>String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#BROKEN"
>BROKEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/String.html"
>String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#EVENTUAL"
>EVENTUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/String.html"
>String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#NEAR"
>NEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;<A HREF="../../../../../org/erights/e/elib/prim/StaticMaker.html"
>StaticMaker</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#OptRefMaker"
>OptRefMaker</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialized lazily to avoid a circular initialization problem</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/UnconnectedRef.html"
>UnconnectedRef</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#TheViciousRef"
>TheViciousRef</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The canonical reference BROKEN by TheViciousMarker.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"
><A NAME="constructor_summary"
><A NAME="constructor_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#Ref()"
>Ref</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"
><A NAME="method_summary"
><A NAME="method_summary"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#broken(java.lang.Throwable)"
>broken</A></B>(<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;problem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Return a Ref broken allegedly because of problem.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#callAll(java.lang.String,java.lang.Object[])"
>callAll</A></B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
        <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Use E.callAll(obj, verb, args) rather than obj.callAll(verb, args).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#commit()"
>commit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used by a resolvers to turn off switchability, and thereby make this
 Ref equivalent to its current target.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#disconnected(java.lang.Throwable,java.lang.Object)"
>disconnected</A></B>(<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;problem,
             <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;prevRef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Return a Disconnected reference -- a broken reference with the same
 identity as some far reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/erights/e/elib/base/TypeDesc.html"
>TypeDesc</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#getAllegedType()"
>getAllegedType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/ProxyHandler.html"
>ProxyHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#getOptProxyHandler(java.lang.Class)"
>getOptProxyHandler</A></B>(<A HREF="../../../../../java/lang/Class.html"
>Class</A>&nbsp;handlerClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  If this is a handled Proxy whose handler is an instance of handlerClass,
 then return that handler; else null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/prim/StaticMaker.html"
>StaticMaker</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#GetRefMaker()"
>GetRefMaker</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#ignore()"
>ignore</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  This default implemetation currently does nothing</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isBroken(java.lang.Object)"
>isBroken</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Is this reference known never to be able to deliver messages?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepFrozen(java.lang.Object)"
>isDeepFrozen</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  XXX Currently just delegates to isDeepPassByCopy, which will make
 errors of omission (the safe kind).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepPassByCopy(java.lang.Object)"
>isDeepPassByCopy</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Would ref be successfully coerced by DeepPassByCopyAuditor?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepPassByCopy(java.lang.Object,org.erights.e.elib.tables.IdentityMap)"
>isDeepPassByCopy</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                 <A HREF="../../../../../org/erights/e/elib/tables/IdentityMap.html"
>IdentityMap</A>&nbsp;optSofar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We move the work to the two argument form so it can break cycles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepPassByCopyClass(java.lang.Class)"
>isDeepPassByCopyClass</A></B>(<A HREF="../../../../../java/lang/Class.html"
>Class</A>&nbsp;clazz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Are instances of clazz necessarily DeepPassByCopy?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isEventual(java.lang.Object)"
>isEventual</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Does this reference support eventual sends but not immediate calls?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isFar(java.lang.Object)"
>isFar</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Is 'ref' both eventual and resolved?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isNear(java.lang.Object)"
>isNear</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Does this reference designate an object in this vat?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isPassByProxy(java.lang.Object)"
>isPassByProxy</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Would ref be successfully coerced by PassByProxyGuard?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isPBC(java.lang.Object)"
>isPBC</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Would ref be successfully coerced by PassByConstructionAuditor?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isPersistent(java.lang.Object)"
>isPersistent</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Can this reference be saved and restored with a <CODE>SerializationStream</CODE> and
 an <CODE>UnserializationStream</CODE> as parameterized by a
 <CODE>PersistenceReplacer</CODE> and
 <CODE>PersistenceReviver</CODE>?
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isResolved()"
>isResolved</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isResolved(java.lang.Object)"
>isResolved</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  A reference isResolved when it is known what object it designates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isSameEver(java.lang.Object,java.lang.Object)"
>isSameEver</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;left,
           <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;right)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  If two object references are the same(), they are indistinguishable up
 to brokeness XXX no longer true, changed to designational equivalence,
 need to write up.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isSelfish(java.lang.Object)"
>isSelfish</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  A NEAR reference that isn't Selfless is Selfish, and designates a
 Selfish object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isSelfless(java.lang.Object)"
>isSelfless</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  A Selfless object only has value-based sameness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isSettled(java.lang.Object)"
>isSettled</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  A reference is settled when it has a fully determined identity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#makeBufferingPromise()"
>makeBufferingPromise</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Currently unused, so we may decide to retire this.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#makeSwitchablePromise(java.lang.Object)"
>makeSwitchablePromise</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Currently unused, so we may decide to retire this.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optBroken(java.lang.Throwable)"
>optBroken</A></B>(<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;optProblem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  If optProblem is null, then return null; else Ref.broken(optProblem)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optProblem()"
>optProblem</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Use Ref.optProblem(obj) rather than obj.optProblem().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optProblem(java.lang.Object)"
>optProblem</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  If isBroken(ref), this returns the alleged reason why it's broken;
 otherwise null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/erights/e/elib/sealing/SealedBox.html"
>SealedBox</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optSealedDispatch(org.erights.e.elib.sealing.Brand)"
>optSealedDispatch</A></B>(<A HREF="../../../../../org/erights/e/elib/sealing/Brand.html"
>Brand</A>&nbsp;brand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  For now, returns null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/sealing/SealedBox.html"
>SealedBox</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optSealedDispatch(java.lang.Object,org.erights.e.elib.sealing.Brand)"
>optSealedDispatch</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                  <A HREF="../../../../../org/erights/e/elib/sealing/Brand.html"
>Brand</A>&nbsp;brand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  If the ref has anything to give to one who has the unsealer for the
 provided brand, ask it to return a SealedBox containing that payload.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/erights/e/elib/base/Script.html"
>Script</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optShorten(java.lang.String,java.lang.Object[])"
>optShorten</A></B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
           <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Return null</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#promise()"
>promise</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Returns the two facets of a local promise -- a SwitchableRef and a
 LocalResolver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolution()"
>resolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Use <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolution(java.lang.Object)"
><CODE>Ref.resolution/1</CODE></A>
 rather than obj.resolution().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolution(java.lang.Object)"
>resolution</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  User-means of Ref shortening.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) abstract &nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolutionRef()"
>resolutionRef</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to implement resolution(), and for internal use in the promise
 package.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#respondsTo(java.lang.String,int)"
>respondsTo</A></B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
           int&nbsp;arity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#sendAll(java.lang.String,java.lang.Object[])"
>sendAll</A></B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
        <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Use E.sendAll(obj, verb, args) rather than obj.sendAll(verb, args).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#sendAllOnly(java.lang.String,java.lang.Object[])"
>sendAllOnly</A></B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
            <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Use E.sendAllOnly(obj, verb, args) rather than
 obj.sendAllOnly(verb, args).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#sendMsg(org.erights.e.elib.prim.Message)"
>sendMsg</A></B>(<A HREF="../../../../../org/erights/e/elib/prim/Message.html"
>Message</A>&nbsp;msg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Eventually sends a packaged message to this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#setTarget(org.erights.e.elib.ref.Ref)"
>setTarget</A></B>(<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A>&nbsp;newTarget)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used by a resolvers to change the target.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html"
>String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state()"
>state</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b>  Use Ref.state(obj) rather than obj.state().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/String.html"
>String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state(java.lang.Object)"
>state</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  One of <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#EVENTUAL"
><CODE>EVENTUAL</CODE></A>, <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#NEAR"
><CODE>NEAR</CODE></A>, or <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#BROKEN"
><CODE>BROKEN</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#toCallable(java.lang.Object)"
>toCallable</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Return an object that's E-equivanetlt to target, but has Java-type
 Callable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#toRef(java.lang.Object)"
>toRef</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Return an object that's E-equivanetlt to target, but has Java-type
 Ref.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html"
>String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#toString()"
>toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#FF0000">Suppressed:</font></i></b></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenBroken(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
>whenBroken</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
           <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Should a breakable reference <i>ever</i> become broken, even if it
 became fulfilled in the meantime, then the reactor is invoked once
 with a broken reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenBrokenOnly(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
>whenBrokenOnly</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
               <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Like <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenBroken(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><CODE>whenBroken(Object, OneArgFunc)</CODE></A> but without a conventional
 return result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenResolved(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
>whenResolved</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
             <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Used for the when-catch construct.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenResolvedOnly(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
>whenResolvedOnly</A></B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                 <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><i><font color="#009000">Enabled:</font></i></b>  Like <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenResolved(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><CODE>whenResolved(Object, OneArgFunc)</CODE></A> but without a
 conventional return result.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"
><A NAME="methods_inherited_from_class_java.lang.Object"
><A NAME="methods_inherited_from_class_java.lang.Object"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="../../../../../java/lang/Object.html"
>Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../java/lang/Object.html#clone()"
>clone</A>, <A HREF="../../../../../java/lang/Object.html#equals(java.lang.Object)"
>equals</A>, <A HREF="../../../../../java/lang/Object.html#finalize()"
>finalize</A>, <A HREF="../../../../../java/lang/Object.html#getClass()"
>getClass</A>, <A HREF="../../../../../java/lang/Object.html#hashCode()"
>hashCode</A>, <A HREF="../../../../../java/lang/Object.html#notify()"
>notify</A>, <A HREF="../../../../../java/lang/Object.html#notifyAll()"
>notifyAll</A>, <A HREF="../../../../../java/lang/Object.html#wait()"
>wait</A>, <A HREF="../../../../../java/lang/Object.html#wait(long)"
>wait</A>, <A HREF="../../../../../java/lang/Object.html#wait(long,int)"
>wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"
><A NAME="field_detail"
><A NAME="field_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="OptRefMaker"
><A NAME="OptRefMaker"
><A NAME="OptRefMaker"
><!-- --></A></A></A><H3>
OptRefMaker</H3>
<PRE>
private static <A HREF="../../../../../org/erights/e/elib/prim/StaticMaker.html"
>StaticMaker</A> <B>OptRefMaker</B></PRE>
<DL>
<DD>Initialized lazily to avoid a circular initialization problem
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="NEAR"
><A NAME="NEAR"
><A NAME="NEAR"
><!-- --></A></A></A><H3>
NEAR</H3>
<PRE>
public static final <A HREF="../../../../../java/lang/String.html"
>String</A> <B>NEAR</B></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="EVENTUAL"
><A NAME="EVENTUAL"
><A NAME="EVENTUAL"
><!-- --></A></A></A><H3>
EVENTUAL</H3>
<PRE>
public static final <A HREF="../../../../../java/lang/String.html"
>String</A> <B>EVENTUAL</B></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="BROKEN"
><A NAME="BROKEN"
><A NAME="BROKEN"
><!-- --></A></A></A><H3>
BROKEN</H3>
<PRE>
public static final <A HREF="../../../../../java/lang/String.html"
>String</A> <B>BROKEN</B></PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="TheViciousRef"
><A NAME="TheViciousRef"
><A NAME="TheViciousRef"
><!-- --></A></A></A><H3>
TheViciousRef</H3>
<PRE>
static final <A HREF="../../../../../org/erights/e/elib/ref/UnconnectedRef.html"
>UnconnectedRef</A> <B>TheViciousRef</B></PRE>
<DL>
<DD>The canonical reference BROKEN by TheViciousMarker.  Used to
 detect vicious forwarding cycles.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"
><A NAME="constructor_detail"
><A NAME="constructor_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Ref()"
><A NAME="Ref()"
><A NAME="Ref()"
><!-- --></A></A></A><H3>
Ref</H3>
<PRE>
public <B>Ref</B>()</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"
><A NAME="method_detail"
><A NAME="method_detail"
><!-- --></A></A></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="GetRefMaker()"
><A NAME="GetRefMaker()"
><A NAME="GetRefMaker()"
><!-- --></A></A></A><H3>
GetRefMaker</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/prim/StaticMaker.html"
>StaticMaker</A> <B>GetRefMaker</B>()</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="promise()"
><A NAME="promise()"
><A NAME="promise()"
><!-- --></A></A></A><H3>
promise</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A>[] <B>promise</B>()</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Returns the two facets of a local promise -- a SwitchableRef and a
 LocalResolver.
 <p>
 The SwitchableRef starts on a BufferingRef, where the LocalResolver
 holds the buffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeSwitchablePromise(java.lang.Object)"
><A NAME="makeSwitchablePromise(java.lang.Object)"
><A NAME="makeSwitchablePromise(java.lang.Object)"
><!-- --></A></A></A><H3>
makeSwitchablePromise</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A>[] <B>makeSwitchablePromise</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;target)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Currently unused, so we may decide to retire this.</I>
<P>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Like Ref.promise(), except the resolving facet is a Switcher rather
 than a Resolver.
 <p>
 With a Switcher, the promise can be redirected repeatedly before being
 committed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeBufferingPromise()"
><A NAME="makeBufferingPromise()"
><A NAME="makeBufferingPromise()"
><!-- --></A></A></A><H3>
makeBufferingPromise</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A>[] <B>makeBufferingPromise</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Currently unused, so we may decide to retire this.</I>
<P>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Returns a pair of a BufferingRef and the FlexList acting as its
 resolver.
 <p>
 To make and hold both facets of a buffering promise without the extra
 allocation, in E do: <pre>
     def Message := &lt;type:org.erights.e.elib.prim.Message&gt;
     def resolver = FlexList.fromType(Message)
     def ref = BufferingRef(resolver)</pre>
 or, in Java, do: <pre>
     import org.erights.e.elib.prim.Message;
     FlexList resolver = FlexList.fromType(Message.class);
     BufferingRef ref = new BufferingRef(resolver);</pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="broken(java.lang.Throwable)"
><A NAME="broken(java.lang.Throwable)"
><A NAME="broken(java.lang.Throwable)"
><!-- --></A></A></A><H3>
broken</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A> <B>broken</B>(<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;problem)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Return a Ref broken allegedly because of problem.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="optBroken(java.lang.Throwable)"
><A NAME="optBroken(java.lang.Throwable)"
><A NAME="optBroken(java.lang.Throwable)"
><!-- --></A></A></A><H3>
optBroken</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>optBroken</B>(<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;optProblem)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  If optProblem is null, then return null; else Ref.broken(optProblem)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="disconnected(java.lang.Throwable,java.lang.Object)"
><A NAME="disconnected(java.lang.Throwable,%20java.lang.Object)"
><A NAME="disconnected(java.lang.Throwable, java.lang.Object)"
><!-- --></A></A></A><H3>
disconnected</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A> <B>disconnected</B>(<A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A>&nbsp;problem,
                               <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;prevRef)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Return a Disconnected reference -- a broken reference with the same
 identity as some far reference.
 <p>
 'prevRef' must currently be a far or disconnected reference.  While
 it seems sensible to allow one to make a Disconnected reference to a
 Near object, there's no way to provide this in Ref without destroying
 our layering -- the independence of local ELib from the CapTP layer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isNear(java.lang.Object)"
><A NAME="isNear(java.lang.Object)"
><A NAME="isNear(java.lang.Object)"
><!-- --></A></A></A><H3>
isNear</H3>
<PRE>
public static boolean <B>isNear</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Does this reference designate an object in this vat?
 <p>
 <tt>isNear/1</tt> must be thread safe, in order for
 <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepPassByCopy(java.lang.Object,org.erights.e.elib.tables.IdentityMap)"
><CODE>Ref.isDeepPassByCopy/2</CODE></A>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state(java.lang.Object)"
><CODE>state(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isEventual(java.lang.Object)"
><A NAME="isEventual(java.lang.Object)"
><A NAME="isEventual(java.lang.Object)"
><!-- --></A></A></A><H3>
isEventual</H3>
<PRE>
public static boolean <B>isEventual</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Does this reference support eventual sends but not immediate calls?
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state(java.lang.Object)"
><CODE>state(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isBroken(java.lang.Object)"
><A NAME="isBroken(java.lang.Object)"
><A NAME="isBroken(java.lang.Object)"
><!-- --></A></A></A><H3>
isBroken</H3>
<PRE>
public static boolean <B>isBroken</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Is this reference known never to be able to deliver messages?
 <p>
 <tt>isBroken/1</tt> must be thread safe, in order for
 <CODE>BootRefHandler.packageArg/4</CODE>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state(java.lang.Object)"
><CODE>state(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="optProblem(java.lang.Object)"
><A NAME="optProblem(java.lang.Object)"
><A NAME="optProblem(java.lang.Object)"
><!-- --></A></A></A><H3>
optProblem</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A> <B>optProblem</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  If isBroken(ref), this returns the alleged reason why it's broken;
 otherwise null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="state(java.lang.Object)"
><A NAME="state(java.lang.Object)"
><A NAME="state(java.lang.Object)"
><!-- --></A></A></A><H3>
state</H3>
<PRE>
public static <A HREF="../../../../../java/lang/String.html"
>String</A> <B>state</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  One of <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#EVENTUAL"
><CODE>EVENTUAL</CODE></A>, <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#NEAR"
><CODE>NEAR</CODE></A>, or <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#BROKEN"
><CODE>BROKEN</CODE></A>.
 <p>
 An EVENTUAL reference is unreliably invokable by E.send() -- ie,
 the message may or may not get delivered to the designated recipient).
 However, it will deliver messages reliably and in order until it
 fails.  Should it fail, it will eventually become broken.
 <p>
 A NEAR reference is reliably invokable by E.send*() and E.call*()
 (and possibly directly by Java's ".").  The object is
 synchronously callable and therefore within the same
 concurrency and atomic failure unit -- the same vat.
 <p>
 A BROKEN reference is one that fails to designate an object.
 It has an associated Throwable that explains what problem
 resulted in this condition.
 <p>
 A Ref may be in any of these three states.  A non-Ref
 is equivalent to a NEAR Ref.  An EVENTUAL Ref may
 become NEAR or BROKEN.  A NEAR Ref must forever remain
 NEAR, and a BROKEN Ref must forever remain BROKEN.
 <p>
 <tt>state/1</tt> must be thread safe, in order for
 <CODE>BootRefHandler.packageArg/4</CODE>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><a href=
 "http://www.erights.org/elib/concurrency/refmech.html"
 >Reference Mechanics</a></DL>
</DD>
</DL>
<HR>

<A NAME="resolution(java.lang.Object)"
><A NAME="resolution(java.lang.Object)"
><A NAME="resolution(java.lang.Object)"
><!-- --></A></A></A><H3>
resolution</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>resolution</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  User-means of Ref shortening.
 <p>
 If isEventual(ref) or isBroken(ref), this returns ref (or a Ref
 equivalent to ref but possibly more efficient).
 <p>
 If isNear(ref), this returns a non-Ref.  The resolution of a NEAR
 reference may be called by both java dot and E.call*(), even if the
 original was only callable by E.call*().  Non-Refs return themselves.
 <p>
 First unwraps deflections.
 <p>
 <tt>resolution/1</tt> must be thread safe, in order for
 <CODE>BootRefHandler.packageArg/4</CODE>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toCallable(java.lang.Object)"
><A NAME="toCallable(java.lang.Object)"
><A NAME="toCallable(java.lang.Object)"
><!-- --></A></A></A><H3>
toCallable</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A> <B>toCallable</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;target)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Return an object that's E-equivanetlt to target, but has Java-type
 Callable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toRef(java.lang.Object)"
><A NAME="toRef(java.lang.Object)"
><A NAME="toRef(java.lang.Object)"
><!-- --></A></A></A><H3>
toRef</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A> <B>toRef</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;target)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Return an object that's E-equivanetlt to target, but has Java-type
 Ref.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isResolved(java.lang.Object)"
><A NAME="isResolved(java.lang.Object)"
><A NAME="isResolved(java.lang.Object)"
><!-- --></A></A></A><H3>
isResolved</H3>
<PRE>
public static boolean <B>isResolved</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  A reference isResolved when it is known what object it designates. <p>

 NEAR and BROKEN references are necessarily resolved.  A reference that
 isn't resolved is a promise, which is necessarily EVENTUAL.  A
 resolved EVENTUAL reference is a Far reference.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><a href=
 "http://www.erights.org/elib/concurrency/refmech.html"
 >Reference Mechanics</a></DL>
</DD>
</DL>
<HR>

<A NAME="isFar(java.lang.Object)"
><A NAME="isFar(java.lang.Object)"
><A NAME="isFar(java.lang.Object)"
><!-- --></A></A></A><H3>
isFar</H3>
<PRE>
public static boolean <B>isFar</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Is 'ref' both eventual and resolved?
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSettled(java.lang.Object)"
><A NAME="isSettled(java.lang.Object)"
><A NAME="isSettled(java.lang.Object)"
><!-- --></A></A></A><H3>
isSettled</H3>
<PRE>
public static boolean <B>isSettled</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  A reference is settled when it has a fully determined identity.
 <p>
 If x and y are settled references, then the E language's 'x == y'
 (which expands to 'Ref same(x, y)' must yield either true or false.
 Whereas if either or both are unsettled, then 'x == y' may instead
 throw a NotSettledException since it cannot yet be determined whether
 further settling will cause the same question to yield true or false.
 <p>
 Only settled references may be used as keys in EMaps (hashtables),
 since only from a fully determined identity is there enough
 information to (internal to the E implementation) calculate a hash.
 <p>
 Settled references are a subset of Resolved references -- unresolved
 references (Promises) are necessarily unsettled.  Objects with
 object-creation identity are "Selfish" (they have a "self").  Those
 without are "Selfless".  For objects defined in the E language, only
 PassByCopy are Selfless, all others are Selfish (and implicitly
 PassByProxy).  Near and Far references to Selfish objects are
 settled.  Broken references are settled.  When a Far reference breaks,
 the corresponding Broken reference retains the settled identity of its
 Far reference, since identity must be stable.  Other Broken references
 are the same iff their problems are the same.
 <p>
 Far references cannot point at Selfless objects (although
 RemotePromises can, as a transient state).  Therefore, the only case
 left is a Near reference to a Selfless object.  A Near reference to a
 Selfless object is settled iff the Selfless object is settled.  Just
 as two Selfless objects are the same iff they are of the same types
 are their parts are recursively the same, a Selfless object is settled
 when all its parts are recursively settled.  For example,
 <pre>    [x, y]</pre>
 is settled iff x and y are both settled.
 <p>
 In the recursive defintions of both sameness and settledness, cycles
 are fine.  For example,
 <pre>    def a := ["left", a, "right"]</pre>
 defines an infinite (cyclic) settled tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSelfless(java.lang.Object)"
><A NAME="isSelfless(java.lang.Object)"
><A NAME="isSelfless(java.lang.Object)"
><!-- --></A></A></A><H3>
isSelfless</H3>
<PRE>
public static boolean <B>isSelfless</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  A Selfless object only has value-based sameness.
 <p>
 Selfless objects are immutable, and compare for sameness based only on
 their type and state.  As a result, an E implementation can
 transparently copy or merge copies of Selfless objects at will, with
 no effect visible from the E language. (XXX talk about rational tree
 comparison.)
 <p>
 isSelfless of a non-NEAR reference is false.  This is a bit weird for
 FarRef, and DisconnectedRef, as they are listed (for implementation
 reasons) as Selfless objects (either actual or HONORARY).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><CODE>org.erights.e.elib.tables.Selfless</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isSelfish(java.lang.Object)"
><A NAME="isSelfish(java.lang.Object)"
><A NAME="isSelfish(java.lang.Object)"
><!-- --></A></A></A><H3>
isSelfish</H3>
<PRE>
public static boolean <B>isSelfish</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  A NEAR reference that isn't Selfless is Selfish, and designates a
 Selfish object. <p>

 Selfish objects have creation-identity, ie, normal EQness. For Selfish
 objects, Java's "x==y" and E's "x==y" (ie, ELib's "E.same(x,y)")
 agree. <p>

 isSelfish of a non-NEAR reference is false.  This is a bit wierd for
 FarRef and DisconnectedRef, as they both have the creation identity of
 the object they (originally) designate(d).  However, for these, E's
 "x==y" does not agree with Java's "x==y".
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPassByProxy(java.lang.Object)"
><A NAME="isPassByProxy(java.lang.Object)"
><A NAME="isPassByProxy(java.lang.Object)"
><!-- --></A></A></A><H3>
isPassByProxy</H3>
<PRE>
public static boolean <B>isPassByProxy</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Would ref be successfully coerced by PassByProxyGuard?
 <p>
 A PassByProxy object is passed between vats by creating a FarRef for
 it on the remote end that forwards back to the original.  PassByProxy
 objects must be Selfish, and only exist in their hosting vat.
 <p>
 It's safe to provide this test, since PassByProxyGuard's coerce()
 either returns ref or fails.  Ie, it doesn't actually coerce.
 <p>
 isPassByProxy of a non-NEAR reference is false.
 <p>
 <tt>isPassByProxy/1</tt> must be thread safe, in order for
 <CODE>BootRefHandler.packageArg/4</CODE>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPBC(java.lang.Object)"
><A NAME="isPBC(java.lang.Object)"
><A NAME="isPBC(java.lang.Object)"
><!-- --></A></A></A><H3>
isPBC</H3>
<PRE>
public static boolean <B>isPBC</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Would ref be successfully coerced by PassByConstructionAuditor?
 <p>
 PassByConstruction objects are passed between vats by constructing a
 new object in the destination vat to serve as its representative.  We
 often speak of the original and each of its representatives
 individually as presences, and the conceptual object that they all
 jointly represent as an Unum.  The most common and most trivial case
 of PassByConstruction is PassByCopy, in which case each presence is a
 Selfess, transparent, immutable copy of each other.
 <p>
 It's mostly safe to provide this test, since PassByConstructionAuditor's
 coerce() either returns ref or fails.  Ie, it mostly doesn't coerce.
 The exception is that coerce() will coerce an Array to a ConstList,
 which should be transparent to the E language programmer.
 <p>
 isPBC on a non-NEAR reference is false, which is a bit wierd for
 UnconnectedRef and DisconnectedRef, as (for implementation reasons)
 they are listed as PassByConstruction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDeepPassByCopy(java.lang.Object)"
><A NAME="isDeepPassByCopy(java.lang.Object)"
><A NAME="isDeepPassByCopy(java.lang.Object)"
><!-- --></A></A></A><H3>
isDeepPassByCopy</H3>
<PRE>
public static boolean <B>isDeepPassByCopy</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Would ref be successfully coerced by DeepPassByCopyAuditor?
 <p>
 It's mostly safe to provide this test, since DeepPassByCopyAuditor's
 coerce() either returns ref or fails.  Ie, it mostly doesn't coerce.
 The exception is that coerce() will coerce an array to a ConstList,
 which should be transparent to the E language programmer.
 <p>
 isDeepPassByCopy on a non-NEAR reference is false, which is a bit wierd
 for UnconnectedRef and DisconnectedRef.
 <p>
 Of all PassByCopy data types where an instance might be considered
 DeepPassByCopy based on a dynamic check of its contents, we currently
 only perform such a dynamic check for arrays and ConstLists.  XXX
 should we instead check ConstMaps and ConstSets as well?  Or perhaps
 all PassByCopy objects, since they are all transparent, so there should
 be a reliable generic way to enumerate all their contents?
 <p>
 <tt>isDeepPassByCopy/1</tt> must be thread safe, in order for
 <CODE>BootRefHandler.packageArg/4</CODE>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDeepFrozen(java.lang.Object)"
><A NAME="isDeepFrozen(java.lang.Object)"
><A NAME="isDeepFrozen(java.lang.Object)"
><!-- --></A></A></A><H3>
isDeepFrozen</H3>
<PRE>
public static boolean <B>isDeepFrozen</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  XXX Currently just delegates to isDeepPassByCopy, which will make
 errors of omission (the safe kind).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDeepPassByCopyClass(java.lang.Class)"
><A NAME="isDeepPassByCopyClass(java.lang.Class)"
><A NAME="isDeepPassByCopyClass(java.lang.Class)"
><!-- --></A></A></A><H3>
isDeepPassByCopyClass</H3>
<PRE>
private static boolean <B>isDeepPassByCopyClass</B>(<A HREF="../../../../../java/lang/Class.html"
>Class</A>&nbsp;clazz)</PRE>
<DL>
<DD>Are instances of clazz necessarily DeepPassByCopy?
 <p>
 <tt>isDeepPassByCopyClass/1</tt> must be thread safe, in order for
 <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepPassByCopy(java.lang.Object,org.erights.e.elib.tables.IdentityMap)"
><CODE>Ref.isDeepPassByCopy/2</CODE></A>
 to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDeepPassByCopy(java.lang.Object,org.erights.e.elib.tables.IdentityMap)"
><A NAME="isDeepPassByCopy(java.lang.Object,%20org.erights.e.elib.tables.IdentityMap)"
><A NAME="isDeepPassByCopy(java.lang.Object, org.erights.e.elib.tables.IdentityMap)"
><!-- --></A></A></A><H3>
isDeepPassByCopy</H3>
<PRE>
private static boolean <B>isDeepPassByCopy</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                                        <A HREF="../../../../../org/erights/e/elib/tables/IdentityMap.html"
>IdentityMap</A>&nbsp;optSofar)</PRE>
<DL>
<DD>We move the work to the two argument form so it can break cycles.
 <p>
 <tt>isDeepPassByCopy/2</tt> must be thread safe, in order for
 <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isDeepPassByCopy(java.lang.Object)"
><CODE>Ref.isDeepPassByCopy/1</CODE></A>
 to be thread safe: Note that optSoFar will always start as null, and
 therefore will only ever hold a thread-specific map, and so need not
 itself be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPersistent(java.lang.Object)"
><A NAME="isPersistent(java.lang.Object)"
><A NAME="isPersistent(java.lang.Object)"
><!-- --></A></A></A><H3>
isPersistent</H3>
<PRE>
public static boolean <B>isPersistent</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Can this reference be saved and restored with a <CODE>SerializationStream</CODE> and
 an <CODE>UnserializationStream</CODE> as parameterized by a
 <CODE>PersistenceReplacer</CODE> and
 <CODE>PersistenceReviver</CODE>?
 <p>
 The cases are <ul>
 <li>Broken references are persistent.
 <li><tt>null</tt> is persistent.
 <li>Instances of <CODE>org.erights.e.elib.serial.Persistent</CODE>
     (including <A HREF="../../../../../org/erights/e/elib/ref/StemCell.html"
><CODE>StemCell</CODE></A>s) are persistent.
 <li>Arrays are persistent.
 <li>Instances of any
     <CODE>org.erights.e.elib.serial.Persistent#HONORARY</CODE> classes are
     persistent.
 <li>A Far reference (a Resolved Eventual reference) is not persistent,
     but is saved as a DisconnectedRef (a kind of BrokenRef) that
     maintains the far reference's sameness identity.
 <li>All other non-persistent references, including all non-StemCell
     Promises (Unresolved references) are saved as UnconnectedRefs
     (Broken references without a sameness identity).
 <ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSameEver(java.lang.Object,java.lang.Object)"
><A NAME="isSameEver(java.lang.Object,%20java.lang.Object)"
><A NAME="isSameEver(java.lang.Object, java.lang.Object)"
><!-- --></A></A></A><H3>
isSameEver</H3>
<PRE>
public static boolean <B>isSameEver</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;left,
                                 <A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;right)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  If two object references are the same(), they are indistinguishable up
 to brokeness XXX no longer true, changed to designational equivalence,
 need to write up. <p>

 The E language's "x == y" expands to "Ref.isSameEver(x, y)".  <p>

 If (x == y && Ref optProblem(x) == Ref optProblem(y)) then
 substituting one for the other must be semantically transparent XXX no
 longer true, changed to designational equivalence, need to write up.
 See <a href="http://www.erights.org/elang/same-ref.html">
 "When Are Two Things the <i>Same</i>?"</a>. <p>

 Sameness is stable, but it is only total among settled references.  If
 'x == y' yield true or false then the same comparison must forever
 afterwards yield the same answer.  However, if either or both are
 unsettled, it may throw NotSettledException instead.

 Throws a NotSettledException if left and right are not yet settled
 enough to determine whether they will designate the same settled
 identity.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="whenResolved(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenResolved(java.lang.Object,%20org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenResolved(java.lang.Object, org.erights.e.elib.util.OneArgFunc)"
><!-- --></A></A></A><H3>
whenResolved</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>whenResolved</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                                  <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Used for the when-catch construct.
 <p>
 If ref never becomes resolved, the reactor is not invoked.
 Should ref become resolved, the reactor will be invoked exactly once.
 For example, if ref becomes fulfilled and then broken, the reactor
 will hear of exactly one of these events.
 <p>
 Once ref becomes resolved the reactor will be invoked with the
 resolution.  Should the reactor be invoked with a non-broken
 value (and therefore a fulfilled value), all earlier messages sent on
 ref before the whenResolved are guaranteed to have been successfully
 delivered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A promise that will resolve to the outcome of calling the
         reactor, as explained <a
 href="http://www.eros-os.org/pipermail/e-lang/2001-August/005638.html"
         >here</a>.<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenBroken(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><CODE>whenBroken(Object, OneArgFunc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="whenResolvedOnly(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenResolvedOnly(java.lang.Object,%20org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenResolvedOnly(java.lang.Object, org.erights.e.elib.util.OneArgFunc)"
><!-- --></A></A></A><H3>
whenResolvedOnly</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A> <B>whenResolvedOnly</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                                         <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Like <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenResolved(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><CODE>whenResolved(Object, OneArgFunc)</CODE></A> but without a
 conventional return result.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Why wasn't the __whenMoreResolved/1 queued?  It isn't queued if
         this vat or comm connection is shut down, in
         which case the returned problem explains why.  If null is
         returned, then the event was queued, though it may still not
         arrive.</DL>
</DD>
</DL>
<HR>

<A NAME="whenBroken(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenBroken(java.lang.Object,%20org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenBroken(java.lang.Object, org.erights.e.elib.util.OneArgFunc)"
><!-- --></A></A></A><H3>
whenBroken</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>whenBroken</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                                <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Should a breakable reference <i>ever</i> become broken, even if it
 became fulfilled in the meantime, then the reactor is invoked once
 with a broken reference.
 <p>
 A vat-crossing reference that gets garbage collected before a
 partition is not broken by that partition, and therefore doesn't need
 to inform the reactor.  Once a reference is logically garbage
 (unreachable), it may or may not have been collected yet, and so may
 or may not inform the reactor of partitions that happen after it is
 garbage.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A promise that will resolve to the outcome of calling the
         reactor, as explained <a
 href="http://www.eros-os.org/pipermail/e-lang/2001-August/005638.html"
         >here</a>.  Note that, if ref becomes near, it'll never break,
         so the returned promise will never be resolved!<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenResolved(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><CODE>whenResolved(Object, OneArgFunc)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="whenBrokenOnly(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenBrokenOnly(java.lang.Object,%20org.erights.e.elib.util.OneArgFunc)"
><A NAME="whenBrokenOnly(java.lang.Object, org.erights.e.elib.util.OneArgFunc)"
><!-- --></A></A></A><H3>
whenBrokenOnly</H3>
<PRE>
public static <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A> <B>whenBrokenOnly</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                                       <A HREF="../../../../../org/erights/e/elib/util/OneArgFunc.html"
>OneArgFunc</A>&nbsp;reactor)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  Like <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#whenBroken(java.lang.Object,org.erights.e.elib.util.OneArgFunc)"
><CODE>whenBroken(Object, OneArgFunc)</CODE></A> but without a conventional
 return result.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Why wasn't the __whenBroken/1 queued?  It isn't queued if this
         vat or comm connection is shut down, in
         which case the returned problem explains why.  If null is
         returned, then the event was queued, though it may still not
         arrive.</DL>
</DD>
</DL>
<HR>

<A NAME="optSealedDispatch(java.lang.Object,org.erights.e.elib.sealing.Brand)"
><A NAME="optSealedDispatch(java.lang.Object,%20org.erights.e.elib.sealing.Brand)"
><A NAME="optSealedDispatch(java.lang.Object, org.erights.e.elib.sealing.Brand)"
><!-- --></A></A></A><H3>
optSealedDispatch</H3>
<PRE>
public static <A HREF="../../../../../org/erights/e/elib/sealing/SealedBox.html"
>SealedBox</A> <B>optSealedDispatch</B>(<A HREF="../../../../../java/lang/Object.html"
>Object</A>&nbsp;ref,
                                          <A HREF="../../../../../org/erights/e/elib/sealing/Brand.html"
>Brand</A>&nbsp;brand)</PRE>
<DL>
<DD><b><i><font color="#009000">Enabled:</font></i></b>  If the ref has anything to give to one who has the unsealer for the
 provided brand, ask it to return a SealedBox containing that payload.
 <p>
 That SealedBox should, of course, be sealed by the sealer for that
 brand, but that's up to the ref. If ref has nothing to give to one who
 has the unsealer for this brand, return null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"
><A NAME="toString()"
><A NAME="toString()"
><!-- --></A></A></A><H3>
toString</H3>
<PRE>
public <A HREF="../../../../../java/lang/String.html"
>String</A> <B>toString</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../java/lang/Object.html#toString()"
>toString</A></CODE> in class <CODE><A HREF="../../../../../java/lang/Object.html"
>Object</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a string representation of the object.</DL>
</DD>
</DL>
<HR>

<A NAME="optProblem()"
><A NAME="optProblem()"
><A NAME="optProblem()"
><!-- --></A></A></A><H3>
optProblem</H3>
<PRE>
public abstract <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A> <B>optProblem</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Use Ref.optProblem(obj) rather than obj.optProblem().
 <p>
 When we're BROKEN, our subclass must return a non-null problem.
 When we're not BROKEN, our subclass must return null.
 <p>
 All implementations of <tt>optProblem/0</tt> must be thread safe, in
 order for <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state()"
><CODE>Ref.state/0</CODE></A> to be thread safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#optProblem(java.lang.Object)"
><CODE>optProblem(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resolutionRef()"
><A NAME="resolutionRef()"
><A NAME="resolutionRef()"
><!-- --></A></A></A><H3>
resolutionRef</H3>
<PRE>
abstract <A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A> <B>resolutionRef</B>()</PRE>
<DL>
<DD>Used to implement resolution(), and for internal use in the promise
 package.
 Our subclass must either provide 'this', or a Ref which is
 equivalent but less indirect.  If the resolutionRef() is 'this', then
 our state() must be BROKEN or EVENTUAL.
 <p>
 All implementations of <tt>resolutionRef/0</tt> must be thread safe, in
 order for <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolution()"
><CODE>Ref.resolution/0</CODE></A> to be thread
 safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resolution()"
><A NAME="resolution()"
><A NAME="resolution()"
><!-- --></A></A></A><H3>
resolution</H3>
<PRE>
public <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>resolution</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Use <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolution(java.lang.Object)"
><CODE>Ref.resolution/1</CODE></A>
 rather than obj.resolution().
 <p>
 Our subclass must either provide 'this', or an object which is
 equivalent but less indirect.  If the resolution() is 'this', then our
 state() must be BROKEN or EVENTUAL.  However, subclasses will
 typically only override resolutionRef().  The only difference between
 the two is on a NearRef.
 <p>
 All implementations of <tt>resolution/0</tt> must be thread safe, in
 order for <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#resolution(java.lang.Object)"
><CODE>Ref.resolution/1</CODE></A> to be thread
 safe.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="state()"
><A NAME="state()"
><A NAME="state()"
><!-- --></A></A></A><H3>
state</H3>
<PRE>
public <A HREF="../../../../../java/lang/String.html"
>String</A> <B>state</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Use Ref.state(obj) rather than obj.state().
 Our subclass *may* override this, but only to return NEAR, EVENTUAL,
 or BROKEN consistent with the above descriptions.  The default
 behavior provided here is defined in terms of optProblem() and
 resolutionRef().
 <p>
 All implementations of <tt>state/0</tt> must be thread safe, in order
 for <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#isNear(java.lang.Object)"
><CODE>Ref.isNear/1</CODE></A> to be thread safe: The
 default implementation here is inductively thread safe even though it
 doesn't synchronize, in that it's made only from thread safe parts used
 together in a monotonic fashion.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/erights/e/elib/ref/Ref.html#state(java.lang.Object)"
><CODE>state(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="optShorten(java.lang.String,java.lang.Object[])"
><A NAME="optShorten(java.lang.String,%20java.lang.Object[])"
><A NAME="optShorten(java.lang.String, java.lang.Object[])"
><!-- --></A></A></A><H3>
optShorten</H3>
<PRE>
public <A HREF="../../../../../org/erights/e/elib/base/Script.html"
>Script</A> <B>optShorten</B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
                         <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Return null
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html#optShorten(java.lang.String,java.lang.Object[])"
>optShorten</A></CODE> in interface <CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="callAll(java.lang.String,java.lang.Object[])"
><A NAME="callAll(java.lang.String,%20java.lang.Object[])"
><A NAME="callAll(java.lang.String, java.lang.Object[])"
><!-- --></A></A></A><H3>
callAll</H3>
<PRE>
public abstract <A HREF="../../../../../java/lang/Object.html"
>Object</A> <B>callAll</B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
                               <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Use E.callAll(obj, verb, args) rather than obj.callAll(verb, args).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html#callAll(java.lang.String,java.lang.Object[])"
>callAll</A></CODE> in interface <CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sendMsg(org.erights.e.elib.prim.Message)"
><A NAME="sendMsg(org.erights.e.elib.prim.Message)"
><A NAME="sendMsg(org.erights.e.elib.prim.Message)"
><!-- --></A></A></A><H3>
sendMsg</H3>
<PRE>
public void <B>sendMsg</B>(<A HREF="../../../../../org/erights/e/elib/prim/Message.html"
>Message</A>&nbsp;msg)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Eventually sends a packaged message to this object.
 <p>
 To the client, this has the same semantics as <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#sendAll(java.lang.String,java.lang.Object[])"
><CODE>sendAll(java.lang.String, java.lang.Object[])</CODE></A> or
 <A HREF="../../../../../org/erights/e/elib/ref/Ref.html#sendAllOnly(java.lang.String,java.lang.Object[])"
><CODE>sendAllOnly(java.lang.String, java.lang.Object[])</CODE></A>, and the default implementation here in Ref just
 delegates to these. However, those subclasses that can reuse
 the Message should do so as a nice optimization, and to preserve the
 <CODE>SendingContext</CODE> info
 captured in <tt>msg</tt> for causality tracing and debugging.
 <p>
 XXX SECURITY ALERT, No longer true:<br>
 This is package scope, since only trusted code is assumed to not
 resuse a Resolver so as to break distributed transparency.  (This
 safeguard isn't crucial, and isn't even a big deal, but is nice.)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sendAll(java.lang.String,java.lang.Object[])"
><A NAME="sendAll(java.lang.String,%20java.lang.Object[])"
><A NAME="sendAll(java.lang.String, java.lang.Object[])"
><!-- --></A></A></A><H3>
sendAll</H3>
<PRE>
public abstract <A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A> <B>sendAll</B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
                            <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Use E.sendAll(obj, verb, args) rather than obj.sendAll(verb, args).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sendAllOnly(java.lang.String,java.lang.Object[])"
><A NAME="sendAllOnly(java.lang.String,%20java.lang.Object[])"
><A NAME="sendAllOnly(java.lang.String, java.lang.Object[])"
><!-- --></A></A></A><H3>
sendAllOnly</H3>
<PRE>
public abstract <A HREF="../../../../../java/lang/Throwable.html"
>Throwable</A> <B>sendAllOnly</B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
                                      <A HREF="../../../../../java/lang/Object.html"
>Object</A>[]&nbsp;args)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  Use E.sendAllOnly(obj, verb, args) rather than
 obj.sendAllOnly(verb, args).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Why wasn't this event queued?  It isn't queued if this
         vat or comm connection is shut down, in
         which case the returned problem explains why.  If null is
         returned, then the event was queued, though it may still not
         arrive.</DL>
</DD>
</DL>
<HR>

<A NAME="isResolved()"
><A NAME="isResolved()"
><A NAME="isResolved()"
><!-- --></A></A></A><H3>
isResolved</H3>
<PRE>
public abstract boolean <B>isResolved</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="optSealedDispatch(org.erights.e.elib.sealing.Brand)"
><A NAME="optSealedDispatch(org.erights.e.elib.sealing.Brand)"
><A NAME="optSealedDispatch(org.erights.e.elib.sealing.Brand)"
><!-- --></A></A></A><H3>
optSealedDispatch</H3>
<PRE>
public <A HREF="../../../../../org/erights/e/elib/sealing/SealedBox.html"
>SealedBox</A> <B>optSealedDispatch</B>(<A HREF="../../../../../org/erights/e/elib/sealing/Brand.html"
>Brand</A>&nbsp;brand)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  For now, returns null.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../org/erights/e/elib/sealing/Amplifiable.html#optSealedDispatch(org.erights.e.elib.sealing.Brand)"
>optSealedDispatch</A></CODE> in interface <CODE><A HREF="../../../../../org/erights/e/elib/sealing/Amplifiable.html"
>Amplifiable</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOptProxyHandler(java.lang.Class)"
><A NAME="getOptProxyHandler(java.lang.Class)"
><A NAME="getOptProxyHandler(java.lang.Class)"
><!-- --></A></A></A><H3>
getOptProxyHandler</H3>
<PRE>
public <A HREF="../../../../../org/erights/e/elib/ref/ProxyHandler.html"
>ProxyHandler</A> <B>getOptProxyHandler</B>(<A HREF="../../../../../java/lang/Class.html"
>Class</A>&nbsp;handlerClass)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  If this is a handled Proxy whose handler is an instance of handlerClass,
 then return that handler; else null.
 <p>
 This is for internal use only. As with other instance methods of Ref it
 is effectively suppressed for taming by virtue of Ref being a kind of
 Callable.
 <p>
 All implementations of <tt>getOptProxyHandler/1</tt> must be thread
 safe, in order for
 <CODE>BootRefHandler.getOptBootRefHandler/1</CODE>
 to be thread safe: The default implementation here merely returns null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAllegedType()"
><A NAME="getAllegedType()"
><A NAME="getAllegedType()"
><!-- --></A></A></A><H3>
getAllegedType</H3>
<PRE>
public <A HREF="../../../../../org/erights/e/elib/base/TypeDesc.html"
>TypeDesc</A> <B>getAllegedType</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html#getAllegedType()"
>getAllegedType</A></CODE> in interface <CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="respondsTo(java.lang.String,int)"
><A NAME="respondsTo(java.lang.String,%20int)"
><A NAME="respondsTo(java.lang.String, int)"
><!-- --></A></A></A><H3>
respondsTo</H3>
<PRE>
public boolean <B>respondsTo</B>(<A HREF="../../../../../java/lang/String.html"
>String</A>&nbsp;verb,
                          int&nbsp;arity)</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html#respondsTo(java.lang.String,int)"
>respondsTo</A></CODE> in interface <CODE><A HREF="../../../../../org/erights/e/elib/base/Callable.html"
>Callable</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ignore()"
><A NAME="ignore()"
><A NAME="ignore()"
><!-- --></A></A></A><H3>
ignore</H3>
<PRE>
public void <B>ignore</B>()</PRE>
<DL>
<DD><b><i><font color="#FF0000">Suppressed:</font></i></b>  This default implemetation currently does nothing
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTarget(org.erights.e.elib.ref.Ref)"
><A NAME="setTarget(org.erights.e.elib.ref.Ref)"
><A NAME="setTarget(org.erights.e.elib.ref.Ref)"
><!-- --></A></A></A><H3>
setTarget</H3>
<PRE>
abstract void <B>setTarget</B>(<A HREF="../../../../../org/erights/e/elib/ref/Ref.html"
>Ref</A>&nbsp;newTarget)</PRE>
<DL>
<DD>Used by a resolvers to change the target.  If newTarget is equivalent
 to this Ref, then this Ref becomes broken by a ViciousCycleException.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="commit()"
><A NAME="commit()"
><A NAME="commit()"
><!-- --></A></A></A><H3>
commit</H3>
<PRE>
abstract void <B>commit</B>()</PRE>
<DL>
<DD>Used by a resolvers to turn off switchability, and thereby make this
 Ref equivalent to its current target.
 <p>
 If the current target is already equivalent to this Ref, then this Ref
 becomes broken by a <A HREF="../../../../../org/erights/e/elib/ref/ViciousCycleException.html"
><CODE>ViciousCycleException</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><A NAME="navbar_bottom"
><!-- --></A></A></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><A NAME="navbar_bottom_firstrow"
><!-- --></A></A></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"
><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"
><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"
><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"
><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"
><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"
><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../elib/legacy/api-legend.html"
><FONT CLASS="NavBarFont1"
><B><font color="#009000"><i>Legend</i></font></B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href="../../../../../../index.html"  target="_top"><img src="../../../../../../images/e-lambda.gif" border="0"></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/Redirector.html"
><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/erights/e/elib/ref/RemotePromise.html"
><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"
><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Ref.html" TARGET="_top"
><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../../allclasses-noframe.html" TARGET=""
><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary"
>METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail"
>FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail"
>CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail"
>METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<center>comments? <a href=http://www.blindpay.com/crit-me-now.cgi><img src=../../../../../../images/cmn.gif width=98 height=21 border=0 align=middle></a></center>
</BODY>
</HTML>

