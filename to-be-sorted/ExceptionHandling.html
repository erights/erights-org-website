<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Exception Handling</TITLE>
<META NAME="Template">
</HEAD>
<BODY BGCOLOR="#ffeedd" TEXT="#000000" LINK="#0000FF" VLINK="#800080">

<I><H1>Exception Handling</H1>
</I><ADDRESS>
This page was originally written by Claire.
</ADDRESS>
<P><B>Last updated:</b><I> [98/06/11 </I><I>Claire</I><I>]</I> </P>
<H2>Introduction</H2>
<P>This document is an attempt to collect from a variety of sources a set of guidelines for handling exceptions.</P>
<H4>Related Documents</H4>
<ADDRESS><A HREF="Tracing.html">Tracing</A></ADDRESS>
<ADDRESS><A HREF="../javadoc/org/erights/e/develop/assertion/package-summary.html">Assertions</A></ADDRESS>
<H2>Requirements</H2>
<P>The general goals of any exception handling scheme is to inform the programmer, testers and users of problems when they occur. Some exceptions are of interest to the programmer and should be handled away from the users eye. Other exceptions are of interest to the user and need to be displayed to the user. Users should not be bombarded by a variety of message styles or continuing stream of dialogs. Fatal errors should notify the user if at all possible and aid the user in reporting the error to testing.</P>
<H2>Architecture</H2>
<H4>Current Architecture Overview</H4>
<P>We have three layers in which exceptions and errors are propagated throughout the system. </P>
<P>The first layer is the Assertion mechanism. We have an assertion class that will allow you to test for boundary conditions on data. This class is not heavily used in the code and should be used more often.</P>
<P>The second layer is the basic Exception mechanism. This just means subclassing Exception and when an exception occurs throwing it. We use the standard java mechanism of throwing exceptions and using try/catch block to trap for exceptions. Currently we have very loose guidelines for using exceptions and even looser ones for catching and throwing them. In addition to the java Exception types we have our own utility class NestedThrowable that can be used to collect exceptions together as they are caught and then rethrown.</P>
<P>The third layer for handling errors and exceptions is the Trace class. This class can be used to filter out exception or error messages and document program flow. Most of our code relies heavily on trace.errrom to push the error outward to the user. The trace class allows the application to attach a UI level class that will actually display messages in a dialog to the user by calling either notifyOptional or notifyFatal.</P>
<P>&nbsp;</P>
<H4>Proposed Architecture Overview</H4>
<H5>Guidelines for future development</H5>
<OL>

<LI>Use Assertions liberally when developing code. Remember however that these calls are not free and be prepared to remove them before shipping the product.</LI>
<LI>You should check the values of all data input from external sources and of all routine input parameters. Use assertions to check for boundary conditions while developing replace them with Exceptions or error output in the final product.</LI>
<LI>You should have a clear plan for how bad parameters will be handled. You may throw an exception or continue processing but you should document how you will handle the condition. This should be part of your design document and javadoc for that code.</LI>
<LI>You should use exceptions rather than error codes to express error conditions. </LI>
<LI>Use the trace system to document the flow of the program. This is especially important for usage and world-level trace statements. These are the primary markers of what the program is doing. Put them in early. Remember these should include enough detail to duplicate the bug; not necessarily to find it.</LI>
<LI>Use of debugging and verbose trace should be kept at the level that makes sense for you to accurately evaluate the problem. Remember that these statements cost and you should be judicious in choosing which ones should be left in for shipping.</LI>
<LI>Any message that will be displayed to the user should be referenced from a file that contains all of the public error messages. This allows these messages to be tailored for different audiences. Furthermore, you need not concern yourself with making your messages user-friendly. This can be handled by a UI person.</LI>
<LI>In addition to NestedThrowable, we should have our own Exception types.
Exceptions should subclass ECException or ECFatal this will allow for errors and exceptions that are generated by Communities.com code to be trapped. The Exception or RuntimeException class should never be thrown since it does not require you to declare it as thrown in the method declaration and it is too broad to be reasonably trapped for.</LI>
<LI>In general, subsystems should have a base Exception type from which all exceptions within that subsystem will throw or inherit. Again this will allow you to trap for a class of errors if necessary. </LI>
<LI>To avoid class bloat consider whether you really need to create a new exception for a specific error or if a more general subsytem error will be adequate.</LI>
<LI>Don't catch an exception, if you can't handle it. Alternatively, if you catch it make sure you throw a different exception and record the original error or use a nestedThrowable.</LI>
<LI>Beware of trapping too widely. Trapping for Exception or Throwable for example may lead to you catching an error that you cannot handle and did not expect.</LI></OL>

<P>In general:</P>

<UL>
<LI>Leave in code that checks for important errors and remove code that checks for trivial errors </LI>
<LI>Remove code that results in hard, non-recoverable crashes. While this may be useful during development, it is not acceptable for a shipping product. Even fatal exceptions should be allowed to reach the top so they can be handled in a more consistent manner.</LI></UL>

<H4>Off the shelf alternatives</H4>
<P>Using a source level debugger should remove such a heavy reliance on debug or verbose trace output.</P>
<P>Some IDE (J++) support assertions directly.</P>
<H4>Other Design Objectives, Constraints and Assumptions</H4>
<H2>Current implementation</H2>
<P>A complete guide to the trace and user level exception notification was documented
  previously by Brian Marick. It can be found <A HREF="Tracing.html">here</A>.
  This should be read both for details on how tracing works as well as guidelines
  for usage of trace and handling exceptions. A summary of the key elements follows:</P>
<H4>Trace Usage:</H4>
<P>Currently we support varying levels of trace output by using a trace object and calling MyTrace.tracekindm("my trace output") At runtime a trace level is set. If the level is at or above the trace's level, the trace message is output. The trace levels are as follows:</P>

<UL>
<LI>Error: Error messages report on some internal error. They don't necessarily lead to the system stopping, but they might. Error messages are always logged. </LI>
<LI>Warning: Warning messages are not as serious as errors, but they're signs of something odd </LI>
<LI>World: World messages track the state of the world as a whole. They are the sort of things world operators ask for specifically, such as "can you tell me when someone connects." They should appear only occasionally, much less often than once per second. This is probably the level used for the on-disk log in the shipped version. </LI>
<LI>Usage: Usage messages are used to answer the question "who did what up to the point the bug appeared?" ("Spock entered Azturf. Spock started trading with Kyra. Kyra gave Spock a diamond in exchange for a lump of coal. Kyra spoke.") They are also used to collect higher-level usability information. This is the level probably used for the transient log in the shipped version; during development, we can set the on-disk log to this level. </LI>
<LI>Event: Event messages describe the major actions the system takes in response to user actions. The distinction between this category and debug is fuzzy, especially since debug is already used for many messages of this type. However, it can be used to log specific user gestures for usability testing, and to log information for testers. </LI>
<LI>Debug: Debug messages provide more detail for people who want to delve into what's going on, probably to figure out a bug. </LI>
<LI>Verbose: Verbose messages provide even more detail than debug. They're probably mainly used when first getting the code to work. </LI>
<LI>Timing: Timing messages are for performance tuning. Whether timing messages are logged is independent of the values of all the other trace variables.</LI></UL>

<P>User trace should be output that would allow a tester to replicate the bug. It should be very similar to the kind of output seen in a console window that is tracking the high-level actions of the user and the response from such an action. Although the line between usage and debugging was blurred by the absence of a "usage" trace when much of the code was written, it seems that the usage and event levels could be bound together.</P>
<P>Error trace should be output that records an error when it occurs. This is the base of our current exception handling support.</P>
<P>Debug trace should be output that would allow a programmer to determine essential information about the bug. This includes details about an error as well as the values or contents of various variables.</P>
<P>Verbose trace should be output that would allow a programmer to obtain details about a specific subsystem during its development.</P>
<H4>Errors and Exceptions</H4>

<UL>
<LI>While an error trace will log to the file, it does not cause a message to display to the user: It must rely on a caller up the chain to actually handle the error display because:</LI></UL>

<OL>
<OL>

<LI>The code at the site of the error may not know whether the error is fatal or nonfatal. </LI>
<LI>Even if it has an opinion, a caller with more global knowledge may have a better one. </LI>
<LI>Given the opportunity, a caller may be able to log state that will be useful in a later popup.</LI></OL>
</OL>


<UL>
<LI>The code that catches an error should log it. Exceptions can be logged at the site of the thrower or at the site of the catcher. A consistent rule is needed to prevent errors from being reported twice or not at all. The thrower may not know enough about the context to correctly log the error, therefore the catcher should log the error. </LI>
<LI>If you catch an exception and throw a different exception, you should either log the discarded exception or throw a NestedThrowable with the original exception included. Either way, the exception will end up in the log. </LI>
<LI>There are two methods that can be used to display an error to a user:</LI></UL>

<OL>
<OL>

<LI>Trace.notifyOptional() : Notify users of non-fatal errors and returns. </LI>
<LI>Trace.notifyFatal() : Notify users of fatal errors and does not return.</LI></OL>
</OL>


<UL>
<LI>The code that finally decides whether the error is fatal or nonfatal should invoke the appropriate dialog. The following are guidelines for using notifyOptional and notifyFatal.</LI></UL>

<OL>
<OL>

<LI>Any code that throws away an exception-representing-a-bug has by definition resolved (somehow) a nonfatal error. It should invoke notifyOptional():</LI>
<LI>The catcher of last resort has to create one of the two kinds of popup. The default behavior is to call notifyOptional(). Specific exception types call notifyFatal(). <I>Currently AssertionFailed and Error are by default nonfatal. We need to develop a base class for our fatal exception types</I>.</LI>
<LI>A method that finds a bug in itself and immediately fixes it should send a notifyOptional():</LI>
<LI>Code that <EM>knows</EM> it's found a fatal bug can call notifyFatal(), but it's probably better to just throw some guaranteed-to-be-fatal exception type. This guarantees even in failure that there is a single exit point for the running application.</LI></OL>
</OL>

<H4>&nbsp;Assertions</H4>

<UL>
<LI>You should use assertions during development to document assumptions made in the code and to expose unexpected conditions. </LI>
<LI>The conditional portion of the assertion should only contain a simple Boolean test. Do not put executing code here. If the assertion is removed using the assertion remover app that code will be removed along with it. </LI>
<LI>The Assertion package was added to provide basic assertion capability to Java. This assertion class provides assertions you can add to your program. If the assertions fail, unchecked exceptions of class AssertionFailed are thrown. </LI>
  <LI>Because Java does not allow for conditional compiles a utility application,
    the Assertion stripper was added to remove assertions. A summary for using
    this application can be found here (XXX file not found).</LI>
</UL>

<H4>Is it JavaDoc'ed? Yes.</H4>
<P>Trace Package org.erights.e.develop.trace</P>
<P>Assertion Package <A HREF="../javadoc/org/erights/e/develop/assertion/package-summary.html"><I>org.erights.e.develop.assertion</I></A></P>
<P>Notification Class GUINotificationManager</P>
<H4>Examples</H4>
<H4>Testing and Debugging</H4>
<H2>Design Issues</H2>
<H4>Resolved Issues</H4>
<H4>Open Issues</H4>
<P>Tracing could be sped up by removing the need to make an Exception in order to parse for line numbers.</P>
<P>Tracing output to multiple output streams would make verbose output more manageable</P>
<P>The current output file is determined from the command line or props file. The trace code does not have access to the name of this file making it impossible for it to do any kind of file cleanup or renaming.</P>
<P>The trace file is currently overwritten. This creates problems.</P>
<P>Currently, every time an error occurs, if the user has set notify optional on, he will go through a popup dialog. This dialog is intrusive and serves only to give the user to note anything he may see. <EM>After discussions with Brian, it seems clear that the repeated display of the dialog is unnecessary. If the appropriate usage and error output is being logged, the log should provide the details necessary to duplicate the bug. Rather than continuously put up a dialog at the end of the session the user will be notified that errors were found while running, the location of log and and where to send the log to. Error dialogs should only be displayed when something cannot or did not take place and the user will need to take some action.</i></P></BODY>
</HTML>
